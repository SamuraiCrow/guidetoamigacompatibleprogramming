<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
</head>
<body>
<h1 id="amiga-compatible-programming-guide">Amiga compatible programming guide</h1>
<p>Preface</p>
<p><em>&quot;ShInKurO, you're becoming the eighth Egypt's plague!&quot;</em> Turrican^, FreeNode #AmigaITA IRC channel, 17/07/2007</p>
<p><em>&quot;becoming.. you are right now! :)&quot;</em> suppah, FreeNode #AmigaITA IRC channel, 07/05/2008</p>
<p><em>&quot;I would be cash for mui lessons:)&quot;</em> kiero, FreeNode #MUI IRC channel, 05/05/2008</p>
<p><em>&quot;shinky listen, I've already told it to you, it's a normal, good and right thing to try code pieces in little programs[...]&quot; &quot;[...]you write a little program to try things, so you reduce your doubts&quot;</em> alfie, FreeNode #AmigaITA IRC channel , 2007</p>
<h2 id="i-who-is-this-for">I Who is this for</h2>
<p>This guide offers a lot of concepts from subjects like software engineering, structured and object oriented programming to referring to the available APIs of the Amiga platform. We recommend the reader follow the suggested links during the guide, in order to obtain a better point of view about the methodologies we will reference. Every subject will be handled in a simulated form sometimes, leaving the task of mastering the subject to the reader, using reference texts which will always be suggested here.</p>
<p>Knowledge explained in this guide is easily accessible to those who know what a compiler is and who have a basic knowledge of the C programming language. If you don't have this knowledge, please read the following C courses first:</p>
<pre><code>http://www.cprogramming.com/tutorial.html   </code></pre>
<h2 id="ii-acknowledgement">II Acknowledgement</h2>
<p>This guide wouldn't exist if some person wouldn't have had the patience to suffer and answer all of my numerous asks about Amiga programming. I thank those people who tolerate to be the betatesters of my programs and those who have advised me about a number of things too. I wish to thank, in random order:</p>
<p>Alfonso &quot;alfie&quot; Ranieri Ikka &quot;itix&quot; Lehtoranta Michal &quot;kiero&quot; Wozniak Michal &quot;mschulz&quot; Schulz Stefano &quot;suppah&quot; Crosara Andrea &quot;guruman&quot; Maniero Fabio &quot;falemangn&quot; Alemagna Davide &quot;Turrican^&quot; Michelini Elena Novaretti Claudio &quot;clros&quot; La Rosa Andrea &quot;afxgrup&quot; Palmatè Joachim &quot;zerohero&quot; Birging</p>
<h2 id="iii-bibliography">III Bibliography</h2>
<ul>
<li>Amiga ROM Kernel Reference Manual: Libraries, 3ª Edition (Commodore-Amiga Inc.);</li>
<li>AmigaDOS Manual;</li>
<li>Amiga User Interface Style Guide;</li>
<li>Amiga Mail Vol. 2;</li>
<li>The Amiga Guru Book, a reference manual (Ralph Babel);</li>
<li>Various articles from Transaction guide on Amiga Magazine (italian magazine);</li>
<li>Guide about AmigaOS (Andrea Carolfi)</li>
<li>AROS System Development Manual</li>
<li>MUI development guide</li>
<li>AmigaOS 4 Software Development Kit</li>
<li>MorphOS Software Development Kit</li>
<li>Software engeneering notes from Stefania Gnesi teacher http://fmt.isti.cnr.it/~gnesi/matdid/IngSoftCap6_8.pdf</li>
</ul>
<h1 id="introduction">Introduction</h1>
<p><em>&quot;There is a insurmountable problem. Which is not about the ego of someone or the commercial and industrial projects. It's simply the litigiosity of the community. We knows, amigans were always fractious like soccer supporters. When they lived at home with mum who checked at what time they were back to home and if they were studiyng, things went well. But when they become independent, they made only messes.&quot;</em> Alfonso &quot;alfie&quot; Ranieri, ATML, 10/12/2007</p>
<h2 id="problems-to-face-when-programming-on-amiga">1.1 Problems to face when programming on Amiga</h2>
<p>There are a multitude of problems for a new Amiga programmer:</p>
<ol style="list-style-type: decimal">
<li>Lack of a good documentation;</li>
<li>Lack of modern tools for application development;</li>
</ol>
<p>Most of the documentation on Amiga systems that is available is outdated, mostly in English, and with a lot of obsolete parts. Throughout this guide we will address the reader to resources still valid in the world of the Amiga reincarnations. In systems such as Windows, MacOSX and Linux there are IDEs (Integrated Development Enviroment) with marvelous features, these programs give the users everything they need to develop software in the simplest and fastest way possible. Unfortunately, the Amiga platform doesn't offer this anymore, except for one IDE, CubicIDE, which offers a lot of features which are present in modern IDEs. By the way, CubicIDE is a pay for use software (at this time, the user licence is about 100 euros, an amount of money which is not always available to students and beginners programmers...), and this software offers guaranteed support only for AmigaOS3.x and MorphOS. So, there isn't any version for AROS. In this guide we'll refer to possible alternatives in the little Amiga universe concerning advanced editors. By the way, the biggest problem above all of these problems: the amiga mentality.</p>
<h2 id="past-and-modern-philosophies-reset-course">1.2 Past and modern philosophies: reset course</h2>
<p>Amiga was born in the 80s, it amazed everyone with its features... If you still don't know much about this, we suggest you read up on it's history, just to understand some good points about the Amiga platform. The user/programmer who is starting a new software project have a valuable cultural and philosophical background, which is the direct product of the trouble his beloved platform went through. This means that some of its ideas should be perfectly shareable if we were in the second half of the 80s, but are completely obsolete if applied in the 21st century. In particular, the amiga philosophies provide:</p>
<ol style="list-style-type: decimal">
<li><p>Lack of a definite design: the programmer starts to code without any planning of what he's going to write;</p></li>
<li><p>Not reusing the available resources: they often develop a software which offers 4 or 5 features identical to already available software. So they often &quot;reinvent the wheel&quot; by not using already available APIs, but rewriting them from scratch instead.</p></li>
<li><p>&quot;Closed&quot; source: the programmer writes the code considering himself as the only developer able to carry on the project. This code is not written for public release, it doesn't have any comprehensive documentation for those who read the code in the future, there are poor comments and the order of function writing is not always understandable;</p></li>
<li><p>Lack of collaboration: an Amiga program is often developed by a single coder, it's very difficult to see two or more Amiga programmers collaborate on the same software.</p></li>
<li><p>Lack of portability: the programmer believes that his own system will last forever, it's the only valid system (&quot;OS4 is better! No MOS is better!&quot;) and will never change. For this reason the code is written in a coder's platform dependent way.</p></li>
<li><p>Focus on assembly optimizations: the lack of the design phase causes the writing of code with non-robust algorythms and, in order to improve software efficiency, the amiga developer prefers to use assembly language.</p></li>
</ol>
<p>It's futile to repeat that the above conventions are (in almost all cases) wrong and bring nothing good to the amiga platform. 21st century software (those that are absent on amiga and that all users need) are developed in this way instead:</p>
<ol style="list-style-type: decimal">
<li><p>Problem analysis and resolution: to develop a software, we first analize the problems it must solve. This analysis consists of a series of phases that will define the work to be done to develop the software without any ambiguity.</p></li>
<li><p>Respect of quality rules: there are procedures and metrics to guarantee the quality of some features of a software, for example reusability and maintainability (= see point 6). Reusability means the reuse of functions and/or modules already written, so the programmer doesn't need to reimplement such features from scratch. This leads to lower production times and higher program reliability, because third party modules are reused in other softwares too, being tested and gaining robustness.</p></li>
<li><p>&quot;Open&quot; code: code is written keeping in mind that it should be understood by someone who has no idea what he's reading. This means that the code should have plenty of documentation and plenty of comments inside the code itself. Code is always written following the same order and considered a public release.</p></li>
<li><p>Using of more human resources to develop software: groups of people can collaborate on the same software. To obtain this, code standards are defined (such as how to indent code, how to insert comments etc...), and code sharing tools, such as svn, are used.</p></li>
<li><p>Portability: it's useless to define the portability meaning, just see projects such as Firefox and Openoffice, or independent programming language such as Java;</p></li>
<li><p>Maintenance: it's a microanalysis phase, in which we try to maintain &quot;alive&quot; the software we developed. In this phase, we can fix bugs (corrective maintenance), add new features (adaptive maintenance) and optimize some parts of the software (perfective maintenance). This phase derives directly from the above points, because the maintenance process can require a huge resource expense if the software wasn't well thought out or the code wasn't well written, sometimes this leads to the dismissal of the software itself.</p></li>
</ol>
<h2 id="what-is-the-amiga-platfrom-today-hints-to-code-portability...">1.3 What is the Amiga platfrom today? Hints to code portability...</h2>
<p>This chapter should appear difficult to who have never used Amiga or have never developed with it's APIs. Reader's doubts should disappear following this guide, so don't worry if you don't understand something initially.</p>
<p>What is the Amiga platfrom? We have to summarize in a single sentence more than twenty years of Amiga history, so we'll be concise: today, the Amiga platform is the combination of four operating systems seemingly independent, whose longevity is intrinsically connected. We refer to the following operating systems:</p>
<ul>
<li>AmigaOS3: http://en.wikipedia.org/wiki/AmigaOS_versions</li>
<li>AmigaOS4: http://en.wikipedia.org/wiki/AmigaOS_versions</li>
<li>MorphOS: http://en.wikipedia.org/wiki/MorphOS</li>
<li>AROS: http://en.wikipedia.org/wiki/AROS_Research_Operating_System</li>
</ul>
<p>Due to the conditions in which these Amiga flavours live, we must think about the reasons we would want to develop something for only one of those amiga flavours, while we could do it for all of them. If our goal is to write software for the Amiga platform and the platform is the result of the combination of these four incarnations, we shouldn't exclude any of them. Any incarnation could prevail over the others for some reason and our software wouldn't have some systems to run on, in other words, our software could unwisely became a non-Amiga software. The chance to run on more than one amiga flavor makes the software more complete: more support for different platforms brings in a larger user base and, therefore, more feedback and testing on its features. This brings a growth of robustness, reliability, completeness and efficiency on the program being developed... Writing &quot;Amiga multiplatform&quot; code is not as difficult as it would appear, but we must follow some tips:</p>
<ol style="list-style-type: decimal">
<li><p>MUI: http://aminet.net/dev/mui/mui38dev.lha ;</p>
<p>First of all, the choice of an API to build a modern graphic interface (in which we don't need to reimplement basic gadgets from scratch or to define procedures for element placement - Layout - or struggle to understand how to &quot;interconnect&quot; graphical objects) must be MUI, or Magic User Interface, instead of other solutions. The MUI API is available for all Amiga flavours, this is what makes MUI a must.</p></li>
<li><p>SDI: http://sourceforge.net/projects/sditools/ ;</p>
<p>Every amiga reincarnation has extended the AmigaOS3.1 APIs in different ways. So, in every reincarnation there is a common API group, an updated and incompatible API group and some new APIs incompatible and probably absent from one incarnation to another. Regarding the second point, some AmigaOS 3.x peculiarities, such as BOOPSI classes' dispatcher implementation, the callback hook system etc... are different from one incarnation to another. To write compatible software some macros are available, they are called SDI tools. Using SDI we can write libraries and other vital parts of our software in a portable way, without knowing how a single thing was reimplemented in AROS or in AmigaOS4, but only knowing the common parts.</p></li>
<li><p>Isolated conditional code:</p>
<p>We've just realized that there are new features in every amiga reincarnation which could be absent in the others. If you want to use these new APIs we suggest to use conditional code (in C language such code is marked between the following instruction: #ifdef, #elif, #else, #endif), inside the vital functions of the software, or to isolate such parts in functions and/or separate files to include in the compilation for only one incarnation or the another.</p></li>
</ol>
<p>In the open source and freely readable amiga software we can find Yam, SimpleMail, Scout, and the MUI classes TextEditor, BetterString, NListxxx. All of these programs, used by all Amiga users, are developed with the above three points in mind.</p>
<h1 id="development-environments">Development environments</h1>
<p><em>&quot;When we need make we need it, as long as it only handles dependencies.&quot;</em> Elena Novaretti, ATML, 28/12/2007</p>
<p><em>&quot;data vu: The vague feeling that you've fixed this particular bug before&quot;</em> Peter Cherna, comp.sys.amiga.programmer, 1991</p>
<h2 id="development-environments-to-write-amiga-programs">2.1 Development environments to write Amiga programs</h2>
<p>First of all, to develop something running on Amiga we need to choose our development system, which can run on the same Amiga platform or on other platforms, such as Windows and Linux. In the latter case, we call it development with a cross compiler. In amiga flavors like MorphOS, AmigaOS4 and newer AROS versions, every compiling guide is useless, because these systems are provided with easy to use installation procedures and documentation for new programmers. Regarding the real execution of our programs, we can run them on the system we compiled it for, but we can use the (Win)UAE emulator for AmigaOS3.x compiled files, and/or AROS running in QEMU or VmWare.</p>
<h2 id="windows-cross-compilers">2.2 Windows cross compilers</h2>
<p>The power of the solution we are about to show is the capability to develop for the Amiga platform even if we don't have a real Amiga computer. In recent times, due to the fact that machines aren't always available to users and that some tools aren't mature on the new Amiga flavors, programmers have released a particular version of the DevC++ IDE, able to compile executables not only for Windows, but for AmigaOS3.x, AmigaOS4.x, MorphOS and AROS too. The version of this IDE is called AmiDevCPP. All we need to compile an Amiga program on Windows is a working installation of AmiDevCPP, downloadable from:</p>
<pre><code>http://amidevcpp.amiga-world.de/</code></pre>
<p>Once you have installed it on Windows, you need to add the additional headers (SDI Tools) in the following paths:</p>
<pre><code>AmigaOS3.x : &quot;C:\CrossCompiler\AmiDevCpp\usr\local\amiga\m68k-amigaos\sys-include&quot;

AmigaOS4: &quot;C:\CrossCompiler\AmiDevCpp\usr\local\amiga\ppc-amigaos\SDK\Local\common\include&quot;

MorphOS: &quot;C:\CrossCompiler\AmiDevCpp\usr\local\amiga\ppc-morphos\sys-include&quot;

AROS: &quot;C:\CrossCompiler\AmiDevCpp\usr\local\amiga\i686-aros\sys-include&quot;</code></pre>
<p>We must pay particular attention to external MUI classes headers, which must be put in a subdirectory called &quot;MUI&quot; inside every above path. We must recreate directories for developers files for third party library headers, these directories must follow the form in which they are distributed.</p>
<p>For those who are already familiar with DevC++ the following steps are trivial, but it's good to list them anyway: the creation of a new software project is very simple in AmiDevCPP, you have to choose the &quot;New-&gt;Project&quot; item on the file menu. Now we can choose to build a Windows project or a project for one of the four Amiga flavors, choosing, for example, a command line program (called &quot;Hello World&quot;). We suggest to choose a newly created directory for the new project. If we want to create a new project from already available sources, we must remove the source file that AmiDevCPP automatically created for us, selecting the item &quot;Remove from project&quot; from the Project menu, and adding our files using the &quot;Add to project&quot; item. The program might ask us to save changes made to the AmiDevCPP example file, simply say no, and the example file will disappear. After having made changes to our source files, to compile the program we simply have to select the &quot;Rebuild All&quot; menu item, in the &quot;Compile&quot; menu. If compilation went well we'll find our executable file in the selected project's directory.</p>
<h2 id="compilation-on-amigaos3.x-gcc">2.3 Compilation on AmigaOS3.x (GCC)</h2>
<p>Amiga programmers in the golden times of their platform had the chance to choose one of the compilers that were developed to program in that time. But over the years the chances to choose were reduced: they could choose SAS-C and GCC. The former was an Amiga specific compiler, easy to use, the latter is the famous compiler born on UNIX, which runs on OS3.x through a wrapper, the ixemul.library. Before the release of MorphOS and AmigaOS4, SAS-C developers discontinued the development of this compiler and, even if the road was clear, amiga users continued to use SAS-C. Even if in recent times a multiplatform Amiga compiler is gaining users, vbcc, which supports only C language, every new incarnation of Amiga uses GCC as its first standard compiler.</p>
<p>Elena Novaretti in addition to this suggests to us:</p>
<p>&quot;[...] the real reason almost people use gcc is another one [...]: porting from linux. The GCC is NOT ANSI C, while vbcc is stricty ANSI C. Linux programs are almost written for gcc and NOT are ANSI-compliant. So, in these days all Amiga programmers merely to do linux porting, gcc (and all complete emulation suite, included geek gadgets etc) is for almost programmers most confortable choose if not even obliged. [...] when you find programs writton on linux which use posix or gnu C library, and these functions are not included into standard C library then it's a very disaster to adapt source to the Amiga. It's for this reason if you use gcc (and perhaps ixemul ;) you will are able to compile them[...]&quot;</p>
<p>As from tradition, GCC for AmigaOS3.x remained at 2.9.x version, and its installation and configuration might lead to the complete abandonment of your ideas about programming on this platform. We must say that a 3.x GCC version for AmigaOS3.x, which is mainly used to build executables for OS3.x from other platforms, such as Linux. In this way OS3.x versions of softwares like Yam, TextEditor MCC and so on can be obtained. GCC 3.x is available in a native OS3.x version too, the links to download it from are the same as the 2.x version:</p>
<pre><code>ftp://ftp.back2roots.org/pub/geekgadgets/baseline

http://ftp.back2roots.org/geekgadgets/amiga/m68k/alpha/gcc/

http://ftp.back2roots.org/geekgadgets/amiga/m68k/snapshots/990529/bin/</code></pre>
<p>The following are the files to download (you can find them searching the above links):</p>
<pre><code>BOOT.lha
gcc-2.95.3-4-bin.tgz
binutils-2.9.1-bin.tgz
fileutils-4.0-bin.tgz
make-3.77-bin.tgz
libamiga-bin.tgz
libnix-1.2-bin.tgz
libm-5.4-bin.tgz
ixemul-48.0-inc-bin.tgz
ixemul-48.0-env-bin.tgz
fd2inline-1.21-bin.lha
GG-docs-0.9-bin.tgz (documentation)
GG-misc-bin.tgz</code></pre>
<p>You can optionally overwrite GCC2.x with the files in the following archives:</p>
<pre><code>gcc-3.4.0-bin.tar.gz 
gcc-3.4.0-bin020.tar.gz  
gcc3-notes.tar.gz  
gcc3fix-20040503.tar.gz </code></pre>
<p>We suggest the installation of GCC on OS3.x only if you have considered the eventuality of reaching some form of nervous breakdown.</p>
<p>Now that we have done the recommendations, depending of what version you decided to install, you'll have to proceed with the installation of GCC 2.x. First unarchive the BOOT.lha file in a directory called GG/. Make two temporary assigns opening a shell:</p>
<pre><code>Assign C: PATH_TO_GG_DIRECTORY/bin ADD
Assign LIBS: PATH_TO_GG_DIRECTORY/Sys/Libs ADD </code></pre>
<p>Now you have some commands available, with which you can uncompress the others archive, like the tar program. In the shell, go into the GG/: directory</p>
<pre><code>cd PATH_TO_GG_DIRECTORY/</code></pre>
<p>Start uncompressing the gcc-2.95.3-4-bin.tgz file in this way:</p>
<pre><code>tar -xvf gcc-2.95.3-4-bin.tgz</code></pre>
<p>Expert users should have noticed that we didn't use the tar's z option, most of the archives we use are only files combined into a single file using tar, without compressing with the bzip algorythm. This action will lead to a number of subdirectories like bin/, lib/, sys-include (or os-include) and so on... Now you have to extract the contents of the other archives using the same extraction path you've previously used for gcc-2.95.3-4-bin.tgz. So, all files will be uncompressed and put in the correct directories automatically. Now you have to modify your User-Startup in S: with a text editor, adding the following instructions:</p>
<pre><code>Assign GG:   DIRECTORY_PATH_GG/
Assign C:    GG:bin ADD
Assign LIBS: GG:Sys/Libs ADD
Assign S:    GG:Sys/S ADD</code></pre>
<p>Execute GG:Sys/S/GG-Startup</p>
<p>Remember to modify GG:Sys/S/GG-Startup also, and to delete the following instructions:</p>
<pre><code>Assign DEVS: GG:Sys/Devs ADD
Assign L:    GG:Sys/L    ADD</code></pre>
<p>Reset your Amiga and you should have a working standard GCC environment. Under such conditions you should be able to compile the classic hello world in C:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    printf(<span class="st">&quot;Hello world!</span><span class="ch">\n</span><span class="st">&quot;</span>);
    
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>Save these lines of code in a txt file called hello.c and compile everything with:</p>
<pre><code>gcc hello.c -o ram:hello</code></pre>
<p>The compiler shouldn't complain about any problems, producing the executable called &quot;hello&quot;, RAM: resident. Now you simply have to launch the &quot;hello&quot; program from the shell, if everything went fine you should see this classic message in the shell:</p>
<pre><code>Hello World!</code></pre>
<p>Now it's time to install support to compile complex Amiga programs: the NDK3.9. The following site:</p>
<pre><code>http://www.zerohero.se/cross/os3.html</code></pre>
<p>offers a nice preconfigured NDK3.9, ready to be executed with GCC, the archive is:</p>
<pre><code>http://www.zerohero.se/cross/files/m68k-amigaos/ndk-3.9-includes.tar.bz2</code></pre>
<p>Download and uncompress it, you'll obtain a directory called &quot;amiga&quot;, inside you'll find the m68k-amigaos directory, which contains the &quot;sys-include&quot; directory. Rename &quot;sys-include&quot; to &quot;os-include&quot; and copy the latter inside the GG/ directory. Now you have to complete the NDK3.9 with some files that can be found at the following address:</p>
<pre><code>http://yamos.svn.sourceforge.net/viewvc/yamos/trunk/src/</code></pre>
<p>First of all, open the remote include directory and take all the files in the following directories:</p>
<pre><code>clib/
inline/
libraries/
mui/
proto/</code></pre>
<p>Then copy them into the matching subdirectories inside your GG/os-include directory. The &quot;mui/&quot; subdirectory is not present inside &quot;os-include&quot;, so you have to create it and copy the relative file(s) inside.</p>
<p>Now you need to modify a file: os-include/inline/intuition.h.</p>
<p>Open the above file with a text editor and search the following instructions:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifndef NO_INLINE_STDARG</span>
__inline APTR NewObject(<span class="kw">struct</span> IClass * classPtr, CONST_STRPTR classID, ULONG tagList, ...)
{
  <span class="kw">return</span> NewObjectA(classPtr, classID, (<span class="dt">const</span> <span class="kw">struct</span> TagItem *) &amp;tagList);
}</code></pre>
<p>Replace them with these:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co">#ifndef NO_INLINE_STDARG</span>
<span class="co">__inline APTR NewObject(struct IClass * classPtr, CONST_STRPTR classID, ULONG tagList, ...)</span>
<span class="co">{</span>
<span class="co">  return NewObjectA(classPtr, classID, (const struct TagItem *) &amp;tagList);</span>
<span class="co">}</span>
<span class="co">*/</span>

<span class="ot">#ifndef NO_INLINE_STDARG</span>
<span class="ot">#define NewObject(classPtr, classID, tags...) \</span>
    ({ULONG _tags[] = {tags}; NewObjectA((classPtr), (classID), (<span class="dt">const</span> <span class="kw">struct</span> TagItem *) _tags);})
<span class="ot">#endif</span></code></pre>
<p>At last, you get a working GCC environment on AmigaOS3.x. To compile always remember to include the -noixemul option, that makes the creating executable to be independent from ixemul.library. To test the environment we give you an example of a minimal MUI window. The meaning of the following instructions will be explained later. Save the following example as helloMUI.c and compile everything with the following parameters:</p>
<pre><code>gcc helloMUI.c -o ram:helloMUI -noixemul</code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*****************************************************************************/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;proto/intuition.h&gt;</span>
<span class="ot">#include &lt;proto/graphics.h&gt;</span>
<span class="ot">#include &lt;proto/exec.h&gt;</span>
<span class="ot">#include &lt;proto/iffparse.h&gt;</span>
<span class="ot">#include &lt;proto/muimaster.h&gt;</span>
<span class="ot">#include &lt;libraries/mui.h&gt;</span>

<span class="kw">struct</span> IntuitionBase *IntuitionBase;
<span class="kw">struct</span> Library  *MUIMasterBase;

BOOL openLibs(<span class="dt">void</span>)
{
  <span class="kw">if</span> ( !(IntuitionBase=(<span class="kw">struct</span> IntuitionBase *) OpenLibrary(<span class="st">&quot;intuition.library&quot;</span>,<span class="dv">40</span>)) )
    <span class="kw">return</span> <span class="dv">0</span>;

  <span class="kw">if</span> ( !(MUIMasterBase=OpenLibrary(<span class="st">&quot;muimaster.library&quot;</span>,<span class="dv">19</span>)) )
  {
    CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);
    <span class="kw">return</span> <span class="dv">0</span>;
  }

  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">void</span> closeLibs(<span class="dt">void</span>)
{
  <span class="kw">if</span> (IntuitionBase)
    CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);

  <span class="kw">if</span> (MUIMasterBase)
    CloseLibrary(MUIMasterBase);
}

<span class="dt">int</span> main(<span class="dt">int</span> argc,<span class="dt">char</span> *argv[])
{
  Object *app, *window;

  <span class="kw">if</span> (!openLibs())
  {
    printf(<span class="st">&quot;Cannot open libs</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
  }

  app = MUI_NewObject(MUIC_Application,
    MUIA_Application_Title  , <span class="st">&quot;MiaApplicationMUI&quot;</span>,
    MUIA_Application_Description, <span class="st">&quot;This is my first MUI window&quot;</span>,
    
    MUIA_Application_Window, window = MUI_NewObject(MUIC_Window,
      MUIA_Window_Title,<span class="st">&quot;MyMUIWindow&quot;</span>,
      MUIA_Window_ID , MAKE_ID(&#39;W&#39;,&#39;I&#39;,&#39;N&#39;,&#39;D&#39;),
      MUIA_Window_RootObject, MUI_NewObject(MUIC_Group,
        MUIA_Group_Child, MUI_NewObject(MUIC_Text,
          MUIA_Text_Contents, <span class="st">&quot;Hello MUI World!&quot;</span>,
          TAG_DONE),
        TAG_DONE),
      TAG_DONE),
    TAG_DONE);

  <span class="kw">if</span> (!app)
  {
    printf(<span class="st">&quot;Cannot create application...</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
  }

  DoMethod(window,MUIM_Notify,
           MUIA_Window_CloseRequest,TRUE,
           app,
           <span class="dv">2</span>,
           MUIM_Application_ReturnID,
           MUIV_Application_ReturnID_Quit);

  SetAttrs(window,MUIA_Window_Open,TRUE, TAG_DONE);

  {
    ULONG sigs = <span class="dv">0</span>;

    <span class="kw">while</span> (DoMethod(app,MUIM_Application_NewInput,&amp;sigs) != MUIV_Application_ReturnID_Quit)
    {
      <span class="kw">if</span> (sigs)
      {
        sigs = Wait(sigs | SIGBREAKF_CTRL_C);
        <span class="kw">if</span> (sigs &amp; SIGBREAKF_CTRL_C) <span class="kw">break</span>;
      }
    }
  }

  SetAttrs(window,MUIA_Window_Open,FALSE, TAG_DONE);

  MUI_DisposeObject(app);

  closeLibs();
  
  <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="co">/****************************************************************************/</span>         </code></pre>
<p>As we've already said, the result will be a file that, when executed, will show a MUI window. Remember to install the auxiliary SDI Tools and headers you need. A last tip: this example code is meant to be compiled only on AmigaOS3.x. The changes required to make the code more portable will be explained later.</p>
<h3 id="preconfigured-68k-gcc-environment">2.3.1 Preconfigured 68k GCC environment</h3>
<p>For those who didn't have the courage to configure a GCC environment from scratch on OS3.x, a file has been attached, which contains a ready to use GCC environment. To install it you simply have to have a new 100MB empty hardfile in your WinUAE configuration, format it calling it &quot;Develop&quot; from AmigaOS3.x on WinUAE and uncompress the lha archive with the lha command inside of this virtual hard disk. Now, you have to modify your s:user-startup in this way:</p>
<pre><code>Execute Develop:ADE/ADE-Startup</code></pre>
<p>From the next system reboot you'll have a ready to use GCC environment available, with other useful programs for Amiga development.</p>
<p>On a classic Amiga you simply have to uncompress the archive inside a directory called &quot;Develop&quot;, and next modify your user-startup in this way:</p>
<pre><code>Execute [PATH_DIRECTORY_DEVELOP]/ADE/ADE-Startup </code></pre>
<p>We must say that everything you add in the ADE:os-include directory must be done following the rules explained in the previous paragraphs.</p>
<p>The files inside the archives are up to date, so the installed header files are for AmigaOS3.9 (NDK_3.9, that you'll find inside the archive). The MUI headers belong to the 3.8 version of MUI, eventually the os-include/libraries/mui.h file should be updated.</p>
<h2 id="texteditors-to-write-programs-on-amiga">2.4 TextEditors to write programs on Amiga</h2>
<p>Let's start from a general consideration: there isn't as fast and efficient a TextEditor like CubicIDE for Amiga. It's likely the only software you should desire that compares to other operating systems. On Windows, Notepad++ offers something similar, but it doesn't support many of the features of CubicIDE. Considering CubicIDE as only a TextEditor is reductive, this software is more than a simple TextEditor, it's the reference IDE for software development on Amiga.</p>
<p>IDEs like DevC++, Netbeans, XCode are really slow even on modern machines, they are not very intuitive, although they offer more features than CubicIDE.</p>
<p>By the way, it's hard to find a valid an alternative to CubicIDE outside the Amiga platform, and it's impossible to find it inside the small software set that this platform has inherited over the years.</p>
<p>Once we explained the situation about CubicIDE, it must be specified that the price of this software is unobtainable to people without money, the full licence is sold at 100 euros. Sometimes, CubicIDE's author sells the license through some limited time promotion, or he offers the license in a development version which only supports C/C++ at a lower price, even if the overall price has never been lower than 50 euros. If you can buy CubicIDE, our advice is to do it immediately...</p>
<p>You can use a lot of different TextEditors to write C sources. The valid freeware &quot;alternatives&quot; available are:</p>
<ul>
<li>BareED, BlackEditor and TuiTED on OS3.x;</li>
<li>Annotate on OS4;</li>
<li>BlackEditor, MorphED on MorphOS (It's an old version of CubicIDE OEM);</li>
<li>JanoEditor on AROS;</li>
</ul>
<p>All of these TextEditors offer the main features you come to expect, such as cut&amp;paste, configurable tab handling, undo, redo and so on... Each of these TextEditor have some limitations, for example BareED and TuiTED do not offer a preferences panel to the user and force the user to act manually on icons' tooltypes, the OS4 version of Annotate is not always stable, JanoEditor and BlackEditor don't offer any syntax highlighting, BareED and Annotate don't handle more files in a single session, and so on...</p>
<p>Now that we have underlined the main defects of the above listed editors, the good features of these softwares are their intuitiveness and the overall speed and efficiency. We have tested many other freeware editors, but some of them were too complex, or they crashed the machine if used heavily. Some examples are Vim and FreeED. The former is a very powerful editor, but from the installation to its configuration and use, this famous software forces the user to do a careful study of its manual, same for FreeED and many others.</p>
<p>On AROS, it's gaining form a developers IDE called Murks!IDE, which can be worth paying attention. Murks!IDE is freeware and opensource, written in C++, and uses Zune for its graphical interface. So, this software is totally portable to all Amiga flavors. It's good to underline that Murks!IDE is still at the beginning of its evolution, and it's still very limited. We suggest you try this software on AROS, or at least keep an eye on it, take a look at its sources too.</p>
<h2 id="amiga-documentation-historical-books">2.5 Amiga documentation: historical books</h2>
<p>The last paper publications for developers about developing software for Amiga are from the early 90s and are difficult to find. We must list the main paper guides that accompanied Developers during the best period of this platform. These books introduce and master the AmigaOS1.3/2.04 programming, so many parts are obsolete, even if they explains the common foundations on which modern amiga flavors are based on. If you find them, preserve them jealously, more for a historical and affective reason than for their educational value. The most important books are called Amiga ROM Kernel Reference Manuals, they are:</p>
<ol style="list-style-type: decimal">
<li><p>Libraries : explains system libraries, talks about subjects like Intuition, BOOPSI, GadTools, ASL, Workbench, Icon, how libraries are made, ports, messages, semaphores, etc...;</p></li>
<li><p>Devices: talks about the Commodore's few released devices like serial.device, parallel.device, audio.device, clipboard.device, and it contains the first documentation about the IFF format;</p></li>
<li><p>Include &amp; Autodocs : it's mainly a printed version of autodocs and Amiga includes (version 2.04);</p></li>
</ol>
<p>There are also:</p>
<ol start="4" style="list-style-type: decimal">
<li><p>Amiga Hardware Reference Manual: explains old Amiga platform's OCS and ECS chipsets in detail.</p></li>
<li><p>AmigaDOS Manual: it's the only official documentation from Commdore about AmigaDOS, processes and Filesystem;</p></li>
<li><p>Amiga Intuition Reference Manual: it's written by the original fathers of the Amiga, and it's similar to the Style Guide (see below);</p></li>
</ol>
<p>And:</p>
<ol start="7" style="list-style-type: decimal">
<li><p>Amiga Programmer's Guide to ARexx: ARexx programming manual;</p></li>
<li><p>User Interface Style Guide: a guide to build graphical interfaces following some Amiga philosophies. It talks about Workbench, ARexx and Preferences too, although in a introductory way.</p></li>
<li><p>Guru Book: talks about AmigaDOS, filesystem, Shell, 68k assembly programming on Amiga, the use of C language using SAS-C compiler;</p></li>
</ol>
<p>Basically, the most educational book of this era is Libraries, followed by AmigaDOS Manual and Style Guide. The other books deal with outdated parts of the Amiga system and so reading them could be misleading for those who want to start Amiga programming. So, it's always a good idea to have Libraries, AmigaDOS Manual and Style Guide books available.</p>
<h3 id="amiga-documentation-the-electronic-format">2.5.1 Amiga documentation: the electronic format</h3>
<p>Most of the Amiga documentation for the Amiga operating system and third party APIs is distributed in electronic format. Even the Amiga ROM Kernel Reference Manuals can be found in electronic format on the developers CD. There are articles completing the RKRM which are called Amiga Mail volume 2, they talk about changes made to AmigaOS 3.0 and are available in electronic format, usually inside the Development CD (not free). These articles explain the old AGA chipset, datatypes, some BOOPSI classes introduced in AmigaOS3.0, the debug, TCP/IP etc... on Amiga. They are articles from 1993/1994 and so are a bit outdated. Documentation about AmigaOS 3.5 can be found inside the last Developer CD, AmigaOS 3.9 docs is inside the archive called NDK3.9.</p>
<p>Every new flavor of Amiga is accompanied with a series of electronic documents that explains the main differences between every amiga flavor and AmigaOS3.x.</p>
<p>Regarding the most common electronic format for developers documentation, they are AutoDoc, AmigaGuide, HTML and PDF. The last two are easily readable on platforms other than Amiga, AmigaGuide is simply an hypertext format that the guides of Amiga programs were distributed with. We'll talk about AutoDoc here.</p>
<h3 id="autodoc-or-robodoc">2.5.2 Autodoc or Robodoc</h3>
<p>Autodoc is an ASCII text format written with a particular syntax. In the Amiga, there are readers that allow us to read an autodoc as if it were a hypertext, although these programs are handled only with the particular text formatting inside an AutoDoc. An AutoDoc file is usually the output of a particular program that can extract comments from a source code file and translate them into AutoDoc. Obviously, comments must be written following particular rules to have them converted into one or more AutoDocs.</p>
<p>The idea of AutoDoc is from Commodore's times, they thought about a way to maintain API documentation up to date without forcing the programmer to update API documents as well as the API code. So a program called &quot;AutoDoc&quot; was born and released with the official documentation of the first versions of AmigaOS.</p>
<p>Luckily there is an open alternative for all Amiga flavors: Robodoc.</p>
<p>(You can find it on Aminet for AmigaOS3.x, inside our Develop_XX.lha and DevAROS_XX.zip files, with the reader AutoDocReader, already configured to read system and MUI AutoDocs).</p>
<p>Robodoc follows the same idea of the Commodore's program, adding new interesting features, for which we introduce you to the documentation attached to the program itself. Robodoc documentation explains the AutoDoc standard and how to write comments for your code.</p>
<p>All of the documentation of the Amiga and MUI APIs are in AutoDoc format, so we suggest you get familiar with these files and choose a program to handle them that suits your needs, such as AutoDocReader.</p>
<h2 id="debugging-on-amiga-how-to-find-errors-in-our-programs">2.6 Debugging on Amiga: how to find errors in our programs</h2>
<p>Introducing the subject of searching for errors in programs to those who have no idea of how an Amiga compatible system is structured requires some knowledge about the system on which we will program. For this reason we'll introduce some basic concepts of AmigaOS, postponing the rest to the following chapter.</p>
<h3 id="amiga-a-system-without-memory-protection">2.6.1 Amiga: a system without memory protection</h3>
<p>An Amiga compatible OS doesn't have memory protection due to its own nature. You surely already know what &quot;memory protection&quot; is, but it's better to explain this concept here:</p>
<p>Memory protection is a feature of all modern operating systems. Basically a memory protected system executes each program giving it a portion of memory, which is shown to the program process as if it were all the memory available in the machine. The executed program handles this memory as usual, nevertheless it's unable to access other memory portions, because the system itself prevents it from being aware of them. To reach this goal, the system uses some parts of the CPU (like the MMU), so to have memory protection in a system, we need the underlying hardware support.</p>
<p>At its beginning, the Amiga system used a Motorola 68000 processor, which was a processor lacking MMU and other parts that every modern CPU of our century is equipped with. Additionally, the project of the Amiga platform was born with a console/computer thing in mind, so the original team gave more attention to the multimedia features of the platform instead of protection techniques of the operating system. Keep in mind that we are referring to the early 80s, when consoles and home computers ruled the market, these machines had very poor power and resources and so they couldn't face slow downs caused by protection techniques, even if they were not supported by the underlying hardware.</p>
<p>For these reasons, the Amiga original system allows a process to read and write datas onto other processes' memory, and many Amiga APIs (such as Hook and IPC support, used everywhere) uses this opportunity to get better performance. Obviously, if a program contains an error, the wrong writing of a memory area causes unexpected situations that lead to the so hated Amiga crashes. Even the amiga system parts might be involved in an abnormal situation, at least in the original Amiga system, and this can lead to a freeze that forces the user to reboot the machine. In other words, while an error in a process inside a protected memory system involves only the process itself, the same error on an Amiga system might involve other processes and the entire system.</p>
<h3 id="enforcer-and-amiga-compatible-systems">2.6.2 Enforcer and Amiga compatible systems</h3>
<p>As we previously explained, an Amiga system doesn't have memory protection and if a software bug occurs we would notice it only when the system freezes. Anyway, the Amiga platform, since its first version based on Motorola 68000, has evolved in a short time, until using more modern processors like 68030 on Amiga 3000 and many other expansion boards sold in the early 90s. Even the operating system evolved from its first 1.x version to the more stable 2.x, anyway no major work has been done on memory protection, in order to maintain backward compatibility with old software and machines. With the arrival of MMU equipped 68030 processors, at least some debug software was developed that used this hardware feature, Enforcer was the most used.</p>
<p>Enforcer uses MMU to detect reading and writing done by an Amiga program during execution. The main task of Enforcer is to report every attempt to read/write memory regions which should be accessible only from system modules. Furthermore, this debug tool blocks every attempt to read/write nonexistent memory areas. If a program is going to read a &quot;protected&quot; area from Enforcer, it will catch the read attempt, it will show what happened to the user (signaling the, so called &quot;Enforcer Hit&quot;) and will pass zero instead of the real memory address to the bugged program. In the case of a wrong writing attempt, Enforcer will report this action the the user.</p>
<p>In Amiga compatible systems, like MorphOS, AROS and AmigaOS4 we can find typical protections done by Enforcer on AmigaOS3.x already implemented. Anyway, it's good to advise you that such features are available in AROS only in recent times, with the new 64bit kernel, and we hope that such features will be inherited to the 32 bit kernel soon. Regarding AmigaOS4, besides the usual Enforcer protections, the free memory areas, stack memory areas of every program and freed memory areas are protected from following illegal access too.</p>
<p>If you are developing through WinUAE, there is an ad hoc Enforcer version called winuaeenforcer, inside the emulator's archive.</p>
<h3 id="mungwall-memguard-wipeout">2.6.3 MungWall / MemGuard / WipeOut</h3>
<p>We've already pointed out that a memory protection for free and freed memory areas is already being contemplated in AmigaOS4. Handling of these memory areas could be controlled before the arrival of this Amiga compatible system, using a special debug tool called MungWall. Although AmigaOS4 already protects these parts, the use of a tool such as MungWall is useful to find memory handling problems inside our programs, even in this Amiga compatible system. The counterpart of MungWall on AmigaOS4 is MemGuard, in MorphOS another alternative called WipeOut should work. AROS has MungWall's features already built in, and if this Amiga system has been compiled with debug options (all nightly builds are compiled this way) such features can be used. Let's show how MungWall works. MungWall has two main tasks:</p>
<ul>
<li><p>Mung: to mark all free/freed/uninitialized memory areas with special odd values;</p></li>
<li><p>Wall: to allocate a handful of memory before and after every allocation done by a program. Such limited areas are marked with a value and are enriched with some information to perform tests. Such limited areas can be compared to &quot;walls&quot;;</p></li>
</ul>
<p>Regarding the first MungWall task, first of all the marking of free/freed/uninitialized memory areas with an odd value should bring serious problems to programs containing errors. Indeed, there are a lot of chances that the reading (unexpected/wrong) of these values instead of NULL will cause a visible abnormal behavior of bugged programs. Somehow, these programs are put in a stress condition by MungWall, in order to emphasize wrong uses of memory areas. The second task of MungWall allows us to understand if our allocations/deallocations are carried out in the proper way. More precisely, if a program were to free up more memory than allocated, MungWall will report this incident. MungWall's tasks are intrinsically linked to the work of Enforcer, in fact, if a program read a MungWall set odd value or a &quot;wall&quot; value, it's likely that the program would generate an Enforcer Hit, and all of this would allow us to identify more easily the error in our program.</p>
<p>Our friend Bernd Roesch we also noted:</p>
<p>On AmigaOS3.x there is gccfindhit on Aminet, to find the sourceline where the hit came. It's similar to OS4 addr2line [see paraghraph 2.6.5]. On 68k, programs need to be built with the -g option.</p>
<p>To get segment offsets you need to start segtracker during boot and (winuae)Enforcer outout print out segment offset and large stack backtrace.</p>
<p>[N.B.: Almost all programs AmigaOS runs are loaded by the system as segments using the LoadSeg()'s dos.library call. So most code in memory is structured as &quot;segment list&quot;. It's possible to get corrupted segment lists if something overriding the standard LoadSeg() not using the correct seglist format, or something is trashing memory on your system. Using SegTracker while is running Enforcer, it will try to trace back into the segment lists of the task causing the hit.]</p>
<p>You can use a graphical debugger such as Barfly(on Aminet) to single step your program.</p>
<p>Before you start your program type in a shell (winuae) Enforcer 1 then an illegal mem access will give an illegal address access requester. But before you jump into debugger, it's better to set (winuae) Enforcer 0 to switch off the illegal address stop mode, because debuggers also like to access illegal addresses. The mode can always at any time be changed. Now you can choose on barfly post mortem and you can grab the task that is stopped by the Guru requester and single step it.</p>
<h3 id="sashimi-and-the-serial-port">2.6.4 Sashimi and the serial port</h3>
<p>Most of the debug tools on Amiga like Enforcer and MungWall route their output to the serial port, this means that we should have a device, usually another connected computer, which we can intercept debug information with. Anyway, not all people have a debug &quot;station&quot;, for this reason we use Sashimi, a tool to route to the command line interface all the information that goes through the serial port. Sashimi allows us to view all output routed to the serial port, but it also allows us to save the output of a file, in order to analyze it more carefully. Further information on Sashimi is available in the documentation of this tool.</p>
<p>Not closely tied to Sashimi is the use of functions that route their output to the serial port, such as kprintf(). The syntax of kprintf() is identical to that of printf(), so you shouldn't have problems. Every flavor of Amiga has their unique way to provide the facility of sending strings to the serial port, for this reason we should use conditional code that allows us to use a macro in every cases:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifdef __amigaos4__</span>
    <span class="ot">#define __KPRINTF DebugPrintF</span>
<span class="ot">#else</span>
    <span class="ot">#define __KPRINTF kprintf</span>
<span class="ot">#endif</span>

<span class="ot">#ifdef _DBUG</span>
    <span class="ot">#define KPRINTF __KPRINTF</span>
<span class="ot">#else</span>
    <span class="ot">#define KPRINTF if (0) __KPRINTF</span>
<span class="ot">#endif</span></code></pre>
<p>Such code, that must be included in every file to debug, allows us to use the KPRINT() macro in every flavor of Amiga. More precisely, before this code, if we want to &quot;activate&quot; our serial output, we should add:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define _DBUG</span></code></pre>
<p>in order to send through KPRINTF() the debug information that we consider useful. If you don't define _DBUG symbol, the conditional code lines will replace all KPRINTF() calls with empty lines. Anyway, it's good to underline that this way of sending output to the serial port is only one example. You must keep in mind that debug functions like kprintf() are not automatically available, and you often will have to use the respective libraries containing such functions.</p>
<p>In both the Develop_XX.lha archive and the DevAROS_XX.zip distribution you can launch preconfigured Sashimi in order to save your own output in a file inside the Debug-Output directory. To get this result you have to execute the Debug-Startup script, inside the Debug/ directory for Develop_XX.lha and in S: for DevAros_XX.zip.</p>
<h3 id="amigaos4-grimreaper-and-addr2line">2.6.5 AmigaOS4, GrimReaper and addr2line</h3>
<p>AmigaOS4 offers the chance to use a popular UNIX tool to develop native programs: addr2line. To use addr2line we first have to compile our program with gcc, using the -ggdb option. In this way the resulting executable will be full of additional information that will be shown if the program crashes. As the AmigaOS4 users know, a crash in the system involves the execution of a particular tool called Grim Reaper, which assists the user during the abnormal behavior of a program in a friendly way, providing a lot of information regarding the error that occured. Anyway, such information is not available if the program that caused the error wasn't compiled with the -ggdb option. Only if it is compiled in this way, do we have the chance to find the exact point our program has crashed. After the -ggdb compiled program has crashed, we have to act as follow:</p>
<ol style="list-style-type: decimal">
<li>Click on &quot;Other&quot; button on GrimReaper;</li>
<li>Click on &quot;Stack Trace&quot; page;</li>
<li>Click on &quot;Build Stack Trace&quot; button;</li>
</ol>
<p>Now a list of our program's functions will be shown. The uppermost shown function in the list is the one that has produced the problem in the crashed program. The following items refers to function's steps running at the time of the crash. Each of these items has the following form:</p>
<pre class="sourceCode c"><code class="sourceCode c">function_name()+offset1 (section sectionNumber @ offset2)</code></pre>
<p>For example, the MUI3.9's Slidorama demo in AmigaOS4 crashes at this point:</p>
<pre><code>muimaster.library:CustomClassDispatcher()+0x8C (section 1 @0x992c)</code></pre>
<p>To understand what offset2 is related to you simply need to use the debug tool, included in AmigaOS4, called addr2line in such way:</p>
<pre><code>ppc-amigaos-addr2line -e program_name -f offset2</code></pre>
<p>In our example:</p>
<pre><code>ppc-amigaos-addr2line -e Slidorama -f 0x992c</code></pre>
<p>After all, the offset1 that we have considered is useful if we want to disassemble the object code of our program. If you need to do such a thing we suggest that you read the appropriate guide inside the AmigaOS4's SDK.</p>
<h1 id="basic-knowledge-for-amiga-programming">Basic knowledge for Amiga programming</h1>
<p>&quot;AmigaOS is a microkernel message-passing design, with better response time and performance than any other readily available PC operating system: including MINIX, OS/2, Windows, MacOS, Linux, UNIX, and <em>certainly</em> MS-DOS.</p>
<p>The microkernel design has proven invaluable. Things like new file systems that are normally available only from the vendor are hobbyist products on the Amiga. Device drivers are simply shared libraries and tasks with specific entry points and message ports. So are file systems, the window system, and so on. It's a WONDERFUL design, and validates everything that people have been saying about microkernels. Yes, it takes more work to get them off the ground than a coroutine based macrokernel like UNIX, but the versatility pays you back many times over.&quot;</p>
<p>Peter Da Silva, The Tanenbaum-Torvalds Debate, 07/02/1992</p>
<h2 id="excursus-discussion-on-amiga-os">3.1 Excursus (discussion) on Amiga OS</h2>
<p>Introducing programming concepts starting from scratch is very hard: you are never sure if a concept has been explained in a clear way and if it's better to discuss a particular theory before or after another one. Let's try to proceed by applying some base rules for the understanding of this and following chapters:</p>
<ul>
<li>To know the basics of C language;</li>
<li>To know the basics of operating systems;</li>
</ul>
<p>All Amiga APIs are designed to be used with C language, or even 68k assembly if on OS3.x, but since we are in 21st century it's better to focus on the most famous medium-level language that everyone has heard at least talked about once. Assuming that you have mastery of concepts such as functions, pointers, structures, casting, API (Application Programming Interface) etc... Let's introduce some amiga related concepts.</p>
<h2 id="inside-amigaos">3.2 Inside AmigaOS</h2>
<p>All Amiga flavors have AmigaOS3.1 as their common root, so a little look to the 90s of AmigaOS is needed. AmigaOS is a monouser multiprogrammed operating system, mainly built on three important components:</p>
<ul>
<li>An atypical microkernel called MultitaskingExecutive (Exec);</li>
<li>AmigaDOS;</li>
<li>Intuition;</li>
</ul>
<p>And there are other more or less relevant modules.</p>
<p>Exec is AmigaOS's microkernel. Exec's job is to handle the whole system and its resources, running programs (called tasks), message ports and many other things.</p>
<p>AmigaDOS is the module that handles AmigaOS's I/O and offers:</p>
<ul>
<li>A command line interface;</li>
<li>Processes: the tasks that can use particular functions;</li>
<li>Filesystem related APIs, which organizes datas on storage devices. On AmigaOS a filesystem is a process, used by applications to communicate through message exchange.</li>
</ul>
<p>Intuition provides AmigaOS graphical objects to interact with the user. Although AmigaOS's graphical interface has intuition as its core, there are other tools, built on intuition, that allow you to build GUIs quickly:</p>
<ul>
<li>GadTools, should ease the making of new gadgets and menus;</li>
<li>ASL, allows an easier making of Requesters;</li>
<li>BOOPSI, allows you to extend and improve Intuition through the object oriented technique (OOP). BOOPSI is essentially a collection of classes to build graphical objects;</li>
<li>Workbench, a system program that uses graphical symbols, called icons, useful to interact with the filesystem offered by AmigaOS;</li>
</ul>
<p>AmigaOS is, more generally, organized following an overlapped modules hierarchy; starting from the lower modules we have:</p>
<ul>
<li>resource: a collection of low level functions that allow direct access to the system hardware;</li>
<li>device: a collection of functions that control character and block I/O devices and, more generally, all available hardware using AmigaOS IPC tecnique;</li>
<li>library: collection of functions for different uses;</li>
<li>system programs;</li>
</ul>
<p>Libraries are organized according to a hierarchy of levels, following the set of functions that they collect; in fact there are groups of functions that work in a lower level than other groups. Devices and resources don't have the same organization, because each of them handles the devices for which it was designed. Libraries are used for most of the tasks to be performed, devices and resources are only used in particular cases. Such design makes AmigaOS a modular Operating System, giving the opportunity to extend and update its features without interfering with existing applications.</p>
<h2 id="using-amiga-functions">3.3 Using Amiga functions</h2>
<p>Every program that uses the functions of an operating system, here AmigaOS and spin-offs, must be able to access such APIs. On AmigaOS, using library functions, devices and so on, means making available such modules to the application. For this reason we need the opening process of one or more libraries at the beginning of every program.</p>
<p>On AmigaOS there is always a library opened: exec.library, which offers the functions that exec provides to the programmer. For example, if we want to create a requester, using the EasyStruct structure, defined in &lt;intuition/intuition.h&gt; :</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> EasyStruct {
    ULONG es_StructSize;    <span class="co">/* structure dimentsion                */</span>
    ULONG es_Flags;         <span class="co">/* usually set to 0                    */</span>
    UBYTE *es_Title;        <span class="co">/* requester&#39;s title                   */</span>
    UBYTE *es_TextFormat;   <span class="co">/* string inside the requester         */</span>
    UBYTE *es_GadgetFormat; <span class="co">/* string inside the close button      */</span>
};</code></pre>
<p>and the Intuition's EasyRequestArgs() function, declared in this way:</p>
<pre class="sourceCode c"><code class="sourceCode c">LONG EasyRequestArgs(<span class="kw">struct</span> Window *window,               <span class="co">/* window which the  */</span>
                                                          <span class="co">/* requester belongs */</span>
                                                          <span class="co">/* to;               */</span>
                              
                     CONST <span class="kw">struct</span> EasyStruct *easyStruct, <span class="co">/* requester to      */</span>
                                                          <span class="co">/* open;             */</span>
                     LONG *idcmpPtr,                      <span class="co">/* a particular      */</span>
                                                          <span class="co">/* event that closes */</span>
                                                          <span class="co">/* the requester     */</span>
                     CONST APTR args );                   <span class="co">/* optional          */</span>
                                                          <span class="co">/* arguments...;     */</span></code></pre>
<p>we have to open intuition.library first. To perform this task Exec's function calls OpenLibrary(). When we close the program we need to close all the libraries we opened at the beginning of the program itself, so we use CloseLibrary() to do this. Summarizing, in our example we'll have a situation like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*****************************************************************************/</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;proto/exec.h&gt;</span>
<span class="ot">#include &lt;proto/intuition.h&gt;</span>

<span class="kw">struct</span> IntuitionBase *IntuitionBase;

<span class="dt">int</span> main(<span class="dt">void</span>)
{
  IntuitionBase=(<span class="kw">struct</span> IntuitionBase *) OpenLibrary(<span class="st">&quot;intuition.library&quot;</span>,<span class="dv">39</span>);

  <span class="kw">if</span> (!IntuitionBase)
    <span class="kw">return</span> <span class="dv">0</span>;
  
  <span class="kw">struct</span> EasyStruct requester;
  
  requester.es_StructSize   = <span class="kw">sizeof</span>(<span class="kw">struct</span> EasyStruct);
  requester.es_Flags        = <span class="dv">0</span>;
  requester.es_Title        = <span class="st">&quot;Example requester&quot;</span>;
  requester.es_GadgetFormat = <span class="st">&quot;Exit&quot;</span>;
  requester.es_TextFormat   = <span class="st">&quot;This is a try!&quot;</span>;
  EasyRequestArgs(NULL, &amp;requester, NULL, NULL);

  <span class="kw">if</span> (IntuitionBase)
    CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);
  
  <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="co">/*****************************************************************************/</span></code></pre>
<p>To use library functions, a program needs a pointer to the library's data area, stored somewhere in memory, such area is called &quot;Base&quot;. The base of an OpenLibrary() returned library is nothing more than a structure having its own name (to know the name of the Base of a function, see header protos of the same functions). OpenLibrary() takes the name of the library to open and its minimum version as arguments. If the system cannot find the library we requested or find a previous version that is specified, OpenLibrary() would return NULL.</p>
<p>As we said, the first parameter of OpenLibrary() is the name of the library, such library might already be in memory, in this case OpenLibrary() will open the resident library, anyway, our library might not yet be resident in memory. In this case, OpenLibrary() will refer to the &quot;LIBS:&quot; device (which is usually an assign to Sys:Libs/) to find the library, load it into memory and open it. If you want to specify a different path than &quot;LIBS:&quot;, you'll have to insert the path with the name of the library as first parameter of OpenLibrary(), for example:</p>
<pre class="sourceCode c"><code class="sourceCode c">OpenLibrary(<span class="st">&quot;sys:foo/bar.library&quot;</span>, <span class="dv">0</span>);</code></pre>
<p>In this way we open any version of bar.library resident in sys:foo/. Although AmigaOS id case insensitive, Exec's functions are not case insensitive, so you need to be careful with uppercase and lowercase letters of names specified to OpenLibrary().</p>
<p>The data area of a library is called Base because it specifies the lower part of the memory reserved to a particular library. Before the Base, or if we want &quot;above&quot; the base, there is another structure called functions table. Functions table contains references to all the functions a library provides. The program essentially browses the functions table to find the one which was invoked. After being sure to have a pointer to the Base of the library we are interested in, we can use the functions offered by the library. It's important to note that AmigaOS needs the programmer to expressly close the library, to perform it the CloseLibrary() function is used.</p>
<p>Due to the number of libraries used normally in a program, it's common practice to put the processes of opening and closing libraries inside two different functions, which respectively open and close all the libraries we'll use in our program.</p>
<h3 id="amigaos4-interfaces-and-amiga-oss-preprocessor-symbols.">3.3.1 AmigaOS4 interfaces and Amiga OS's preprocessor symbols.</h3>
<p>AmigaOS4 introduces some changes relating the access of library functions. In the previous paragraph we learned how a program needs to get the Base of a library to access its functions. Using the Base the program gains the capability to access the table of functions of the corresponding library. On AmigaOS4 a new version of shared libraries has been introduced, called &quot;interfaces&quot;. On AmigaOS4 it is still not possible to access directly the library functions simply opening it with OpenLibrary(), you'll need to specify first which interface contains the functions we'll refer to. Basic functions of a library are pointed to from the &quot;main&quot; interface, on OS4 even the AmigaOS3.x APIs are accessible through this interface. So, while on AmigaOS3.x we only needed to get access to the Base of a function with OpenLibrary(), on AmigaOS4 we'll also need to access the interface of the library, &quot;main&quot; in our case. To obtain all these things there are two new functions in ExecSG (the new AmigaOS4 kernel), called GetInterface() and DropInterface(), used respectively to open and close an interface. The previous paragraph's example become the following:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*****************************************************************************/</span>
<span class="ot">#include &lt;proto/exec.h&gt;</span>
<span class="ot">#include &lt;proto/intuition.h&gt;</span>

<span class="kw">struct</span> Library *IntuitionBase;
<span class="kw">struct</span> IntuitionIFace *IIntuition;

<span class="dt">int</span> main(<span class="dt">void</span>)
{
  IntuitionBase= (<span class="kw">struct</span> Library *) IExec-&gt;OpenLibrary(<span class="st">&quot;intuition.library&quot;</span>,<span class="dv">39</span>);

  <span class="kw">if</span> (!IntuitionBase)
    <span class="kw">return</span> <span class="dv">0</span>;
  
  IIntuition = (<span class="kw">struct</span> IntuitionIFace *) IExec-&gt;GetInterface(IntuitionBase, 
                                 <span class="st">&quot;main&quot;</span>, <span class="dv">1</span>, NULL);
  
  <span class="kw">if</span> (!IIntuition)
  {
    IExec-&gt;CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);
    <span class="kw">return</span> <span class="dv">0</span>; 
  }             
  
  <span class="kw">struct</span> EasyStruct requester;
  
  requester.es_StructSize   = <span class="kw">sizeof</span>(<span class="kw">struct</span> EasyStruct);
  requester.es_Flags        = <span class="dv">0</span>;
  requester.es_Title        = <span class="st">&quot;Example requester&quot;</span>;
  requester.es_GadgetFormat = <span class="st">&quot;Exit&quot;</span>;
  requester.es_TextFormat   = <span class="st">&quot;This is a try!&quot;</span>;
  IIntuition-&gt;EasyRequestArgs(NULL, &amp;requester, NULL, NULL);
  
  
  IExec-&gt;DropInterface((<span class="kw">struct</span> Interface *)IIntuition);

  <span class="kw">if</span> (IntuitionBase)
    IExec-&gt;CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);
    
  <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="co">/*****************************************************************************/</span></code></pre>
<p>First of all, it's good to notice how the name of Base structure is not referring to a given library anymore, except for rare cases (see the relating documentation). As for exec.library, even the IExec interface for this library is already open and available to the programmer. Every function is now invocable only explicitly by a direct access to the relating interface, such as IIntuition-&gt;EasyRequestArgs(). This makes it difficult to keep compatibility with other Amiga flavors, so you can use two preprocessor's symbols __USE__INLINE__ and __USE_BASETYPE__, which allows us to keep the AmigaOS3.x function syntax and to use specific names for libraries' Bases. Our example, rewritten in a portable manner becomes:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*****************************************************************************/</span>
<span class="ot">#ifdef __amigaos4__</span>
<span class="ot">#define __USE_INLINE__</span>
<span class="ot">#define __USE_BASETYPE__</span>
<span class="ot">#endif</span>
<span class="ot">#include &lt;proto/exec.h&gt;</span>
<span class="ot">#include &lt;proto/intuition.h&gt;</span>

<span class="kw">struct</span> IntuitionBase *IntuitionBase;
<span class="kw">struct</span> IntuitionIFace *IIntuition;

<span class="dt">int</span> main(<span class="dt">void</span>)
{
  IntuitionBase= (<span class="kw">struct</span> IntuitionBase *) OpenLibrary(<span class="st">&quot;intuition.library&quot;</span>,<span class="dv">39</span>);

  <span class="kw">if</span> (!IntuitionBase)
    <span class="kw">return</span> <span class="dv">0</span>;
  
  <span class="ot">#ifdef __amigaos4__</span>
  IIntuition = (<span class="kw">struct</span> IntuitionIFace *) GetInterface(IntuitionBase,  
                            <span class="st">&quot;main&quot;</span>, <span class="dv">1</span>, NULL);
  
  <span class="kw">if</span> (!IIntuition)
  {
    CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);
    <span class="kw">return</span> <span class="dv">0</span>; 
  } 
  <span class="ot">#endif      </span>
  
  
  <span class="kw">struct</span> EasyStruct requester;
  
  requester.es_StructSize   = <span class="kw">sizeof</span>(<span class="kw">struct</span> EasyStruct);
  requester.es_Flags        = <span class="dv">0</span>;
  requester.es_Title        = <span class="st">&quot;Example requester&quot;</span>;
  requester.es_GadgetFormat = <span class="st">&quot;Exit&quot;</span>;
  requester.es_TextFormat   = <span class="st">&quot;This is a try!&quot;</span>;
  EasyRequestArgs(NULL, &amp;requester, NULL, NULL);
  
  
  <span class="ot">#ifdef __amigaos4__</span>
  DropInterface((<span class="kw">struct</span> Interface *)IIntuition);
  <span class="ot">#endif</span>
  
  <span class="kw">if</span> (IntuitionBase)
    CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);
    
  <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="co">/*****************************************************************************/</span></code></pre>
<p>As you can see, we also used the conditional compilation directives, so if the source is not being compiled on AmigaOS4, calls to GetInterface() and DropInterface() would be ignored by the compiler. The symbols for the four amiga systems, of our example use the conditional code #id defined() are:</p>
<pre><code>AmigaOS3.x :  #if defined (__AMIGA__) &amp;&amp; !defined (__PPC__)
AmigaOS4   :  #if defined (__amigaos4__)
MorphOS    :  #if defined (__MORPHOS__)
AROS       :  #if defined (__AROS__)</code></pre>
<p>To be honest, we could omit the following conditional code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifdef __amigaos4__</span>
<span class="ot">#define __USE_INLINE__</span>
<span class="ot">#define __USE_BASETYPE__</span>
<span class="ot">#endif</span></code></pre>
<p>In this case we should use __USE_INLINE__ and __USE_BASETYPE__ symbols using the -D option of GCC, in other terms:</p>
<p>gcc mySource.c -o myExecutable -D__USE_INLINE_ -D__USE_BASETYPE_</p>
<h2 id="differences-between-various-amiga-os-types">3.4 Differences between various Amiga OS types</h2>
<p>As you surely know, the established range of values to represent integer and decimal variables changes depending on the architecture an operating system is running on. Since its first version, AmigaOS defines also other types to declare variables, which reside in the header file exec/types.h. It's important to notice that such types are dependent from the architecture in which AmigaOS has born, in other words the Motorola 68000 processor, which is a 16/32bit CPU. With the version 4 of AmigaOS and the migration to the PowerPC architecture, more support types were introduced, the same applies to AROS, which, as you know, runs on numerous different architectures. AmigaOS3.x types were maintained for compatibility on both systems, but the relating documentation encourages us to use new types for the future software to be developed.</p>
<p>We must consider that AmigaOS uses a particular type, APTR, if we know that the return value of a function is a generic pointer. Anyway in many cases we do not have such a certainty, so, in similar cases, it's common to use ULONG as return value, which represents a 32 bit unsigned integer. This trick works pretty well for 32 bit architectures, while it's totally incompatible with 64 bit and later ones. The reason is pretty trivial: in the case of pointers larger than 32bit there would be a truncation and thus invalid addresses. In the case of AmigaOS4 and MorphOS for modern architectures there isn't such a problem, because both systems still use 32 bit addresses. In the AmigaOS4 case it's recommended to use a new type, uint32, to avoid any ambiguity regarding the size of the type which is being used. Regarding AROS, the truncation problem is a real situation and easily occurs if you're writing an AROS x86_64 compatible program. For this reason, AROS introduces another new type, IPTR, which is the only portable way to represent a variable that can keep both an integer value as a pointer of any size.</p>
<p>Even MorphOS supports IPTR type.</p>
<p>In the case of portable applications from one Amiga flavor to another, it's good to employ a similar conditional code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#if !defined(__AROS__) || !defined(__MORPHOS__)</span>
    <span class="ot">#ifdef __amigaos4__</span>
    <span class="ot">#define IPTR uint32</span>
    <span class="ot">#else</span>
    <span class="ot">#define IPTR ULONG</span>
    <span class="ot">#endif </span>
<span class="ot">#endif</span></code></pre>
<p>and using IPTR through it.</p>
<h2 id="aros-variable-passing">3.5 AROS, variable passing</h2>
<p>Some AmigaOS functions often requires variable parameters passing, using program stack for their manipulations. As we said, AmigaOS assigns a range of types that ranges from 8bit integers to 64bit integers in modern flavors. Anyway, some modern CPUs don't allow such handling with all variable types. For example, some CPUs allow us to handle only some kind of variable on the stack, other types are accepted only through CPU registers, other CPUs allow variable passing through registers only and so on. To solve such issues, AROS uses a particular symbol, STACKED, which must be put before variable declarations and structures fields to be passed to Amiga functions (such as BOOPSI messages that will be explained later). For portable software, it's good to use such conditional code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifndef __AROS__</span>
<span class="ot">#define STACKED</span>
<span class="ot">#endif          </span></code></pre>
<p>In order to use STACKED without interference with AmigaOS3.x, AmigaOS4 and MorphOS.</p>
<p>For completeness, it's important to specify the STACK symbol too. In many AROS declarations you can find such expressions:</p>
<pre class="sourceCode c"><code class="sourceCode c">STACKULONG foo;

STACKIPTR pointer;</code></pre>
<p>These expressions, although they have the same goal of STACKED, they are not a synonym, in fact:</p>
<pre class="sourceCode c"><code class="sourceCode c">STACKULONG foo;</code></pre>
<p>and</p>
<pre class="sourceCode c"><code class="sourceCode c">STACKED ULONG bar;</code></pre>
<p>Doesn't declare same size variables on AROS, it depends on which architecture we are running this Amiga flavor on. For example, on AROS x86-64 STACKULONG declares a 64bit integer, while STACKED ULONG is a a 32bit integer.</p>
<p>STACK symbol is even supported by MorphOS.</p>
<h2 id="programs-tasks-and-processes">3.6 Programs, tasks and processes</h2>
<p>We often read that a process is a running program, on Amiga it's better to make some distinctions. A running Amiga program is called a &quot;Task&quot;. A task is able to invoke almost all the functions that the Amiga operating system provides, except some, including those offered by AmigaDOS. The only way to execute such functions unavailable to a simple task is to invoke them through a process. A process on Amiga is a special Task, able to use all functions that the operating system provides. The difference between Tasks and Processes must be searched in the AmigaOS history, and we are not going to go deeper in this subject here, we only have to know that when we launch our program, usually it will be a process. Essentially a process on AmigaOS is a task enriched with other information that allows it to also use other resources, among which are some system functions. A task and a process are identified by pointers to structures: the Task structure and the Process structure. What concerns us here is knowing that a process (struct Process) contains within it:</p>
<ul>
<li><p>a reference to a task used by Exec to identify it (struct Task pr_Task);</p></li>
<li><p>a reference to a message port (struct MsgPort pr_MsgPort) see chapter 5.2</p></li>
</ul>
<h1 id="interaction-between-programs-and-users-on-amiga-gui">Interaction between programs and users on Amiga: GUI</h1>
<p><em>&quot;Neither PC, nor Mac, nor Amiga have invented the concept of mouse-driven GUI, but in 1985 Amiga offered certainly its most interesting and complete implementation.&quot;</em> Massimo Tantignone, &quot;VisualPrefs and the Amiga GUI: tips and tricks&quot;, ??/01/2000</p>
<p><em>&quot;Design beautiful Gadgets, Menus, Requesters. Think simplicity and elegance. Always remember the fourth grader, the sophisticated user, and the poor soul who is terrified of breaking the machine.&quot;</em> Robert J. Mical, Amiga Intuition Reference Manual</p>
<p><em>&quot;In my opinion, neither a programmer nor the operating system shall define how GUI elements shall look. The only person who knows the best choice is the user of an application. That's what MUI tries to accomplish. The user of a MUI application can decide if he wants to have standard system scrollers or absolutely fancy designed knobs sliding on a stony background pattern.&quot;</em> Stefan Stuntz, comp.sys.amiga.programmer, 13/08/1993</p>
<p><em>&quot;[...]If you had read the MUI docs more carefully, you would have noticed that all MUI classes are subclasses of rootclass (since every BOOPSI object is a subclass of rootclass)[...]&quot; &quot;[...]Commodore implemented a gadget class and an image class (with several sub classes) and instances of these (and only these) classes are sometimes called by input.device.[...]&quot; &quot;[...]MUI classes are not called by input.device and do not affect system performance[...]&quot;</em> Stefan Stuntz, comp.sys.amiga.programmer, 04/09/1993</p>
<p><em>&quot;From a programmers point of view alone, MUI is heaven. Everything is so much easier than using gadtools. MUI isn't slow, either.&quot;</em> Hans-Joerg Frieden, comp.sys.amiga.programmer, 02/04/1994</p>
<p><em>&quot;I like MUI for its configurability and ease of programming, and hence I use it. [...]GadTools gadgets suck. The can't resize without being removed first, and that something I don't like. Also, you have to control the keyboard, too, which is in my opinion a waste. Additionally, most people use GadTools with a hardcoded font and position, because gadtools (and even BOOPSI without a layout engine) encourages fixed coordinates. There is no way to use the font-size directly to position your gadgets.[...] I do not like the MAGIC prefix, either. But then, I don't judge a program by its name, or else I would consider the BOOPSI concept a VERY bad one.&quot;</em> Hans-Joerg Frieden, comp.sys.amiga.programmer, 11/04/1994</p>
<p><em>&quot;[...]Its imperative for it (MUI) to be as flexible and as extendable as possible.&quot;</em> Stephan Stunz, comp.sys.amiga.programmer, 14/04/1994</p>
<h2 id="tools-to-build-a-graphical-interface-gui-on-amiga">4.1 Tools to build a graphical interface (GUI) on Amiga</h2>
<p>A modern user application offers its features through the use of a graphical interface. Nowadays, a &quot;high level&quot; programmer (he who develops programs without accessing low level resources) should only use features offered by BOOPSI, and use GadTools and Intuition functions only if there is no viable high-level alternative, ready-made BOOPSI classes, that is. Using GadTools functions or other similar primitives entails a waste of energy to write the code, and the final result in many cases may not be consistent with the rest of the Amiga GUI. In order to use BOOPSI, some concepts about object-oriented programming (OOP from now on) must be clear.</p>
<h3 id="oop-primer">4.1.1 OOP primer</h3>
<p>This paragraph is addressed to those being not confortable with OOP; those already familiar with concepts such as instance, object and inheritance, can skip this paragraph.</p>
<p>OOP is based on concepts like classes and objects, which are very close to the way of thinking in human beings.</p>
<p>Consider for example how living beings are classified. For example we have animals, mammals, cats. Let's consider a cat like Sylvester, your neighbour's cat. Sylvester is a specific example of cat, but if we want to refer to cats in general, we shall refer to a generic family of animals, a &quot;class&quot; of animals. A class is a generic entity which holds together common properties; in case of a cat &quot;class&quot; we know that cats have &quot;properties&quot; such as age, the fur color and so on.</p>
<p>An object is a unique representation of a specific entity: in our case we know that Sylvester is a black cat of one year old. In other terms, Sylvester is an &quot;object&quot;. We can identify inside a class structural and behavioural characteristics; in the former case we refer to them with the &quot;attributes&quot; term, while in the latter we talk about &quot;methods&quot;. The attributes of a cat are its colour, age, etc, while the methods in a cat should be its possible actions, such as running, meowing and eating.</p>
<p>A class can be seen as the matrix from which a particular thing is generated: the object. The process of generation of an object is called &quot;instantiation&quot;, therefore an object is an instance of a class with all its attributes and methods.</p>
<p>There are generic classes, such as mammals, and more specific classes, such as the cat. Generally speaking, classes are developed following a hierarchy starting from a very generic class to a more specific one, through a sort of relationship that involves a definite group of classes. In our example we could say that the &quot;cat&quot; class is daughter of the &quot;mammal&quot; class. The &quot;mammal&quot; class is derived from the &quot;animal&quot; class.</p>
<p>The relationships between different classes are described by a special characteristic: a child class is provided with the characteristics of the mother class, and possibly adding also new ones. This mechanism is called hierarchy. In our case, for example, mammals have breasts and eat, characteristics inherited from mammals, but they also have whiskers, claws and they meow.</p>
<p>In OOP, each class has two special methods, called constructor and destructor. The constructor is usually the method that initializes an object instantiated from a class, while the destructor releases the memory the object was using.</p>
<p>There are also the so called setter and getter functions, used to read and write each class' object attribute values. Using getter and setter functions allows the object-oriented philosophy to implement the encapsulation. This concept means that the internal class modules are protected and handled through a method in charge of checking if data provided is correct. For example, if a &quot;cat&quot; class has a &quot;colour&quot; attribute, you cannot simply assign a value to this attribute, one will rather use a &quot;setColour&quot; method; this method will also check whether by mistake a value &quot;sunny&quot; is being assigned to the &quot;colour&quot; attribute.</p>
<p>Obviously, getter and setter methods would be used to their maximum extend if there was a system to hide the attributes of a class from the outside. To this purpose, OOP philosophy offers the chance to define such attributes as &quot;private&quot;, i.e. not directly accessible from the outside. Obviously, there are also &quot;public&quot; attributes that accessible from outside the class. Again, private attributes are not inherited by child classes.</p>
<p>During the process of inheritance, where daughter classes inherit methods from the upper classes, you can have problems of inconsistency. For example we may consider the class of &quot;birds&quot; with a daughter class &quot;penguins&quot;; this class, respecting the rules of hierarchy, will have a &quot;fly&quot; method. But we know that penguins can't fly! This is a typical example of inconsistency in the process of inheritance.</p>
<p>To solve this and other problems it's possible to redefine the behavior of a method that the child class has inherited from the mother class, this process is called method &quot;overriding&quot;. In the above mentioned example, the &quot;fly&quot; method called from a penguin object may have been reimplemented in the penguin class such as to behave as if it were called a method for swimming. Not all methods of a superclass must be inherited by the subclass; there are private methods which can be used only by instances of the class they belong to.</p>
<p>Other classes can be defined inside a class too, either public or private; in the latter case we will have the same behavior described for private attributes.</p>
<p>Finally, all these objects can communicate with each other by exchanging messages. A message in this case is the combination of a method to be invoked and a value of the attributes that this method should manipulate. Example of a message for an object of the class &quot;dog&quot;: method &quot;bark&quot;, the value &quot;woof, woof&quot;.</p>
<h2 id="boopsi-and-mui-some-history">4.2 BOOPSI and MUI: some history</h2>
<p>BOOPSI, Basic Object Oriented Programming System for Intuition, sets the basis for OOP on AmigaOS. The BOOPSI system is developed following a class hierarchy, which are related to a mother class: the rootclass. Since its birth, BOOPSI has had a little number of classes which were a bit extended with AmigaOS 3.0 (1992). Until then BOOPSI didn't have policies about the layout of graphical objects nor had many classes to offer; also, some concepts about the interaction between classes and font handling were quite laborious, and even the look these classes produced was not top notch.</p>
<p>While the small number of classes and the lack of policies for the positioning of the elements in a window allowed great freedom to the management of the graphics application, not everyone was willing to support such an effort for the creation of a graphical interface. For these reasons, again in 1992, a new solution composed of classes was developed, starting right from the rootclass. This solution solved a lot of problems we mentioned, adopting different solutions than those proposed by the few BOOPSI official classes.</p>
<p>Such new classes were released with the name of &quot;Magic User Interface&quot;: MUI was born. During the years, through the long wait for a new version of the operating system, many programmers used MUI as an API to develop their GUI applications, allowing the system to become increasingly robust, comprehensive and versatile. In 1995 ClassAct was introduced. It was a new set of &quot;pure&quot; BOOPSI classes, extending the original BOOPSI system following the philosophies of AmigaOS classes. However MUI had already gained the favours of the developers, and the number of applications written using ClassAct never exceeded those developed with MUI. This situation considerably slowed down the development of new ClassAct classes and the debugging of the classes of this distribution, while at the same time new third party MUI classes were born, offering many modern features to programmers and the MUI &quot;core&quot; classes also became increasingly robust with the release of new versions of the distribution.</p>
<p>In 1999, a new AmigaOS version (3.5) was finally distributed. It officially incorporated a new ClassAct version, called Reaction. However, even this attempt to drive developers towards a more &quot;pure&quot; BOOPSI didn't result in programmers abandon MUI. In 2001, with the release of AmigaOS 3.9 which included new Reaction classes, MUI was choosen by MorphOS as its official API for graphical interfaces. In 2002 MUI was reimplemented by AROS, and renamed Zune. In 2004, the pre-release version of AmigaOS 4 was released. This operating system sports both the new Reaction classes and an OEM distribution of MUI, providing the programmers with both solutions. In the end, although Reaction classes have been greatly improved and developed in recent times, they are not available on AROS and MorphOS and have many missing features and bugs on AmigaOS3.x. They also have not the same functionality and robustness of the corresponding MUI classes, and the number of classes available to Reaction programmers is lower than those available to MUI ones. That is why the choice for an Amiga programmer without specific needs is obliged: MUI must be used.</p>
<h2 id="boopsi-programming">4.3 BOOPSI programming</h2>
<p>In the previous paragraph we mentioned that all BOOPSI classes are related to a single mother class called rootclass. The rootclass defines a set of methods, some of them have to be implemented in the child classes. BOOPSI methods are classified by an identifier, called MethodID. The &quot;pure&quot; BOOPSI methods that we will discuss are declared in &lt;intuition/classusr.h&gt;:</p>
<ul>
<li>OM_NEW: constructor;</li>
<li>OM_DISPOSE: destructor;</li>
<li>OM_SET: setter method;</li>
<li>OM_GET: getter method;</li>
</ul>
<p>Each MethodID has a prefix, &quot;OM&quot; for these four mentioned methods, which stands for &quot;ObjectMethod&quot;. As we know, the object-oriented philosophy requires that interaction with an object is made through messages. A BOOPSI message, called &quot;Object Packet&quot;, is made of the MethodID of the method to be invoked and the parameters it accepts. For example, the object packet of the OM_NEW and OM_SET methods is the following structure (defined in &lt;intuition/classusr.h&gt;):</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> opSet{

  STACKED ULONG MethodID;
  
  STACKED <span class="kw">struct</span> TagItem *ops_AttrList;
  
  STACKED <span class="kw">struct</span> GadgetInfo *ops_GInfo; 
}</code></pre>
<p>The first member of the structure is the MethodID, the second member is a pointer to a list of attributes and corresponding values to be assigned, while for the last member, currently not useful for our guide, let's just say that it must be set to NULL in our examples.</p>
<p>We mentioned the second element of the opSet message is a pointer to a list, but what is this TagItem structure? A TagItem, or more shortly tag, is a [key,value] structure defined in &lt;utility/tagitem.h&gt; like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> TagItem {
  STACKED ULONG ti_Tag;  <span class="co">/* Tag identifier, in other words the name     */</span> 
                         <span class="co">/* of the object&#39;s attribute;                  */</span>
           
  STACKIPTR ti_Data;     <span class="co">/* The value to assign the tag; it&#39;s the value */</span>
                         <span class="co">/* to assign to the object&#39;s attribute;        */</span>
}</code></pre>
<p>It's very common, however, handling more tags at a time and for this reason they are saved in an array (called &quot;tag list&quot;) before the message is being dispatched.</p>
<p>In practice, an application sends a message to an object using the AmigaOS function called DoMethodA(), or its variation DoMethod().</p>
<p>Such functions are declared in &lt;clib/intuition_protos.h&gt; on OS4, and are called IDoMethodA() and IDoMethod(), while in all other Amiga OS variants the declaration is in &lt;clib/alib_protos.h&gt;. On OS4, however, these functions can be called using the &quot;old&quot; name without the &quot;I&quot; prefix.</p>
<p>If, for example, we want to modify an object attribute, we should write:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,<span class="dv">0</span>}};
<span class="kw">struct</span> opSet msg = {OM_SET, taglist, NULL};
DoMethodA (object, (Msg)&amp;msg);</code></pre>
<p>In the first line we create a tagList made by two tags, the first is the attribute we want to modify, the second tag is a control attribute closing the taglist declaration. In this case we can use both TAG_END or TAG_DONE.</p>
<p>In the second line we build the actual BOOPSI message, made of the MethodID (&quot;OM_SET&quot;), the attribute/value list to be assigned (&quot;taglist&quot;) and - last - the third member of the opSet structure that, as we said, must be set to NULL in our case.</p>
<p>In the third line we are simply sending the message to our object. There is a shorter method to do this, using the DoMethodA() variation called DoMethod():</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,<span class="dv">0</span>}};
DoMethod(object, OM_SET, taglist, NULL);</code></pre>
<p>This whole procedure is quite laborious and its use is not recommended in practice. There are actually some Intuition's functions ready-made to invoke these BOOPSI methods, which take of performing the right initializations. Such methods are:</p>
<ul>
<li>NewObject() : calls OM_NEW;</li>
<li>DisposeObject() : calls OM_DISPOSE;</li>
<li>SetAttrs() : calls OM_SET;</li>
<li>GetAttrs() : calls OM_GET;</li>
</ul>
<p>Let's modify the last example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,<span class="dv">0</span>}};
DoMethod(object, OM_SET, taglist, NULL);</code></pre>
<p>which becomes:</p>
<pre class="sourceCode c"><code class="sourceCode c">SetAttrs(object, Attribute_ID, Attribute_Value, TAG_END);</code></pre>
<p>Invoking such functions requires passing the tag in the argument list of the function itself, and this passing mode is called &quot;varargs&quot;: a function is variadic when accepts a variable number of arguments.</p>
<p>Handling a variable number of parameters in C language has precise rules, (http://publications.gbdirect.co.uk/c_book/chapter9/stdarg.html) which affect the API of all the incarnation of AmigaOS, so we'll talk in more detail this topic later (The relevant SDI include file is SDI_stdarg.h)</p>
<p>Not all methods explained at the start of this paragraph can be applied to every attribute of an object: some attributes are not configurable, not readable or not initializable. To indicate the applicability of a method on an attribute some flags are included in the documentation of a BOOPSI class:</p>
<ul>
<li>I: If present, the attribute can be handled by OM_NEW;</li>
<li>S: If present, the attribute can be handled by OM_SET;</li>
<li>G: If present, the attribute can be handled by OM_GET;</li>
</ul>
<p>There are other flags that we've not considered, which refer to methods that we still have not examinated.</p>
<h3 id="instantiating-a-boopsi-class">4.3.1 Instantiating a BOOPSI class</h3>
<p>As you surely have guessed from the previous paragraph, we must use the Intuition function NewObject() to instantiate a BOOPSI class; its declaration is the following:</p>
<pre class="sourceCode c"><code class="sourceCode c">APTR NewObject(<span class="kw">struct</span> IClass *privateclass, 
           UBYTE *publicclassID, 
           <span class="dt">unsigned</span> <span class="dt">long</span> tag1, ...);</code></pre>
<p>The first two parameters could be confusing to those who have never used Amiga, so it's time to introduce private and public BOOPSI classes. A private class in BOOPSI is a class without a name (a simple ASCII value). A private class is <em>mostly</em> created by the user to be only employed in his application, while a public class is associated with an ASCII name and so it can also be accessed by other applications beyond the one that contains the declaration and implementation.</p>
<p>Let's return to the NewObject() function, if we pass NULL as first parameter, the function will know that it must create an instance of a public class; and this is the reason why it will ask the name of this class as an ASCII value in the second parameter. Viceversa, if we want to instantiate a private class, we have to pass a pointer to the private class to instantiate as first parameter in NewObject(), but we will deal with this case later.</p>
<p>NewObject() is a variadic function, in fact the second parameter accepts a tag list, which is built &quot;on the fly&quot; on the stack, following the varargs functions rules. The NewObject() function returns a pointer to the instantiated object, or NULL if something went wrong. So, if we have a class whose ASCII name is &quot;WindowPUB&quot;, with a &quot;Title&quot; attribute whose type is STRPTR (pointer to string), we will have something like this:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *objWin; <span class="co">/* Declare a window object */</span>
objWin = (Object *) NewObject(NULL, <span class="st">&quot;WindowPUB&quot;</span>, 
                   Title, <span class="st">&quot;This is a Window&quot;</span>, 
                  TAG_DONE);</code></pre>
<p>We will later include the following call to release the memory used by this BOOPSI object:</p>
<pre class="sourceCode c"><code class="sourceCode c">DisposeObject(objWin);</code></pre>
<p>The original BOOPSI project stated that for every call to the constructor of a class there is sooner or later a call to the destructor of the same class. However, with the new classes, manual calls to every class destructor are very rare: if a class allows to connect other objects to its instance (see the following chapter), the calling to the DisposeObject() function of that class instance will recall the destructor for every object connected to that instance. In other words, we will have a cascade deallocation.</p>
<h3 id="boopsi-adding-an-object-to-another-object">4.3.2 BOOPSI: adding an object to another object</h3>
<p>In the previous chapter we mentioned how some BOOPSI object allow to be connected to other objects. It's probably better to talk about objects contained by other objects. The &quot;containment&quot; is another type of hierarchical relationship in the latest BOOPSI releases, where the contained object becomes, in some manner, &quot;child&quot; of its container. If, for example, we want a window with buttons inside, we simply have to instantiate a window object, the button objects and add these to the newly instantiated window object. So, the button objects are somehow childs of the window object. This is, in other terms, more a logical relationship than a physical one. The handling of the containment in BOOPSI is committed to two methods of the rootclass:</p>
<ul>
<li>OM_ADDMEMBER: add an object to another object;</li>
<li>OM_REMMEMBER: removes a specific object from another object;</li>
</ul>
<p>For example, if we want to add a button object objBut (public class &quot;ButtonPUB&quot; with a &quot;Label&quot; attribute) to the window object objWin we will do the following:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *objBut; <span class="co">/* we declare a button object  */</span>
objBut = (Object *) NewObject(NULL, <span class="st">&quot;ButtonPUB&quot;</span>, 
                Label, <span class="st">&quot;Click me!&quot;</span>, 
                  TAG_DONE);

DoMethod(objWin, OM_ADDMEMBER, objBut); </code></pre>
<p>Otherwise, if we want to remove that button from the window:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(objWin, OM_REMMEMBER, objBut); </code></pre>
<p>In this last case, we have to be careful when releasing the resources, because after disconnecting an object from another we obviously must call explicitly DiposeObject() on the disconnected child object, otherwise the memory will not be released:</p>
<pre class="sourceCode c"><code class="sourceCode c">DisposeObject(objBut);</code></pre>
<h2 id="from-boopsi-to-mui">4.4 From BOOPSI to MUI</h2>
<p>Adding objects to other objects would be an useless feature if such objects don't supply functions to the user. A user is not willing to press a button without obtaining a feedback. Following the OOP programming, an object could interact with another one by exchanging messages or, in other conditions, the handling of an object by a user could lead to the execution of one or more methods. In all these cases we talk about &quot;event notification&quot;.</p>
<p>The handling of notifications on &quot;pure&quot; BOOPSI is quite peculiar as it involves two methods from the rootclass called OM_UPDATE e OM_MODIFY; we must instantiate two child classes of the rootclass called icclass and modelclass and, at the end, we must use the ICA_TARGET and ICA_MAP attributes of these two classes. Moreover, there are other implementation details to follow that make this work a bit laborious. Moreover, if we want to program following the standard OOP, therefore developing with subclasses, &quot;pure&quot; BOOPSI forces to a number of arrangements to follow that lead the programmers' efforts towards the graphical interface instead of the application itself. Another important aspect to keep in mind using &quot;pure&quot; BOOPSI programming is the difficulties to implement GUIs that follows a Multiple Document Interface philosophy (MDI), which is based on repeatedly adding and removing graphical objects on the fly. This lack of &quot;pure&quot; BOOPSI programming will force you to implementation of GUIs based on multiple windows, a philosophy very widespread in the middle of the '90. Another problem not easily solvable with &quot;pure&quot; BOOPSI programming is object management focus, more precisely when many graphical objects want to control shortcuts from keyboard in the same GUI. The standard behaviour of &quot;pure&quot; BOOPSI assigns all inputs to the focused object, so if for example a string object doesn't support that kind of keyboard shortcut, the input will not be managed. In other words &quot;pure&quot; BOOPSI lacks input inheritance between objects. &quot;Pure&quot; BOOPSI programming lacks also drag&amp;drop support between graphical objects of a GUI, so you can't implement a GUI where a user can drag&amp;drop UI components at his own will into windows of your program (like it happens inside the Firefox UI). Sure, you can write from scratch this kind of thing into your &quot;pure&quot; BOOPSI application, but it's not easy and it takes too much time... Luckily the Amiga universe offers a solution to all these problems: the most loved and hated Amiga Users' GUI, in other words: MUI.</p>
<h3 id="mui-overview">4.4.1 MUI: overview</h3>
<p>As already mentioned, MUI is a collection of classes, linked one another following a complex hierarchy that starts from the Notify and Semaphores classes, both children of the rootclass. For the moment we will focus only on the Notify class and all of its subclasses. The Notify class implements a new mechanism to notify events, which is inherited by all its subclasses, following OOP rules. The class hierarchy is shown in the following simple graph:</p>
<pre><code> rootclass                    
 +--Notify                  
 !  +--Family                
 !  !  *
 !  !      
 !  +--Application
 !  !           
 !  +--Window               
 !  !  * 
 !  !        
 !  +--Area                 
 !  !  +--Group
 !  !  *  *</code></pre>
<p>Family is a generic class whose instances are able to keep objects containing other objects. In other words, an instance of Family could contain some Menu objects, that could contain other menu items or other menus as well. Application is a class whose instance represents an application that runs on the system, which can have a variable number of windows (Window class instances).</p>
<p>Finally, the Area class is the mother of all other MUI gadgets and handles all their informations, such as their size, their look and their position. The Area class handles user inputs too. It's important to notice that Area doesn't set the position of the elements inside one of its instances, because Area is a generic class which can be used to build more complex gadgets. Layout handling is performed by a child class of Area, called Group. In theory, all these classes should have a direct relationship; in other words, Area should be child of Window, which should be child of Application which should be child of Family. The author of MUI says that a direct relationship between these classes wasn't possible to implement, due to some BOOPSI limits. Nonetheless, an instance of Application can contain one or more instances of Window, and this is valid also for Family--&gt;Application and for Window--&gt;Area, partially solving the non-physical relationship problem.</p>
<p>Each MUI class is identified by a name preceded by &quot;MUIC_&quot; prefix, a class attribute is identified by the &quot;MUIA_&quot; prefix, a method is identified by the &quot;MUIM_&quot; prefix and so on... All the BOOPSI rules we talked about regarding the methods of the rootclass are valid on MUI too, even if this set of API provides the programmer with an alternative way for object instantiation and destruction. It's possibile to use MUImaster.library's MUI_NewObject() and MUI_DisposeObject() methods instead of NewObject() and DisposeObject(). We'll compare their use creating an instance of the MUIC_Window class:</p>
<pre class="sourceCode c"><code class="sourceCode c">objWin = (Object *) NewObject(MUI_GetClass(MUIC_Window), NULL, 
                                  MUIA_Window_Title, <span class="st">&quot;This is a Window&quot;</span>, 
                              TAG_DONE);</code></pre>
<p>becomes:</p>
<pre class="sourceCode c"><code class="sourceCode c">objWin = (Object *) MUI_NewObject(MUIC_Window, 
                                      MUIA_Window_Title, <span class="st">&quot;This is a window&quot;</span>, 
                                  TAG_DONE); </code></pre>
<p>First of all, we notice that in the first case any MUI class is seen as a BOOPSI private class. The instantiation occurs after getting the pointer to the MUI class using the MUI_GetClass() method. Such procedure can be problematic sometimes, as MUI_GetClass() keeps open the class we are getting the pointer from, until the FreeClass() function is called; so, forgetting to invoke FreeClass() could generate errors in the code. MUI_NewObject() solves the problems of MUI class opening and closing because a single call to DisposeObject() or MUI_DisposeObject() will leave the system clear. Again, if MUI_NewObject() will not be able to instantiate an object containing more objects previously instanced, it will deallocate these objects that should have been part of the new object (not created).</p>
<h3 id="mui-an-example-of-a-simple-graphical-interface">4.4.2 MUI: An example of a simple graphical interface</h3>
<p>Let's try building a simple graphical interface with MUI, we want to get a window with a string as first element, and a button beneath it as second element. Using MUI classes we will have the following snippet of code for the button:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *button = MUI_MakeObject(MUIO_Button, <span class="st">&quot;Click me!&quot;</span>);</code></pre>
<p>As you can see, we don't instantiate an object from a class, but we get an object from a so called &quot;prebuilt object&quot;. We talked about how the Area class handle user input, this class can react to some input in a variety of ways, such as reacting like it was a button, or something totally different. This is why MUI doesn't have a generic button class; in fact on MUI a button is an instance of the MUIC_Text class with a border as attribute and a behaviour assigned to react to the release of a mouse or keyboard button. This way, it's very simple to create more complex gadgets, but it's a bit awkward building a simple button. For this reason, MUI provides pre built objects, ready for use. These objects are identified by the &quot;MUIO_&quot; prefix. The MUI_MakeObject() function takes a prebuilt object as first parameter plus its optional parameters that aren't a tag list (therefore there isn't TAG_END or TAG_DONE as last parameter). This is how we instantiate a String from the MUIC_String class:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *string = MUI_NewObject(MUIC_String, 
                                    MUIA_Frame, MUIV_Frame_String, 
                                    MUIA_String_Contents, (IPTR) <span class="st">&quot;Click on the button...&quot;</span>, 
                                TAG_DONE);</code></pre>
<p>Please notice the MUIA_Frame attribute that allows to define the border in which our string will be put.</p>
<p>As we mentioned, in order to delegate MUI to arrange the gadgets layout we must use the MUIC_Group class:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *group = MUI_NewObject(MUIC_Group,
                                   MUIA_Group_Child, string,
                                   MUIA_Group_Child, button,
                               TAG_DONE);</code></pre>
<p>The default layout of the objects linked to an instance of MUIC_Group is to align them in the same column, in which the first inserted element will be the first element at the top of the column. To change the layout we must work on the attributes provided by the MUIC_Group class. We recommend reading the relevant documentation.</p>
<p>At the end, we can instantiate our window:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *window = MUI_NewObject(MUIC_Window,
                                     MUIA_Window_Title, <span class="st">&quot;My Window&quot;</span>,
                                     MUIA_Window_ID ,MAKE_ID(&#39;M&#39;,&#39;a&#39;,&#39;i&#39;,&#39;n&#39;),
                                     MUIA_Window_RootObject, group,
                                 TAG_DONE);</code></pre>
<p>In this last instantiation process we can notice the MUIA_Window_ID attribute, which allows the system to identify the window with an ID (using the MAKE_ID() macro our characters will be condensed in an ULONG. This macro is in &lt;libraries/iffparse.h&gt;). This attribute is important if the user wish to save, for example, the size of the program window. Everything will be transparent to the programmer. We must pay attention to the MUIA_Window_RootObject attribute. It establishes what the windows is going to contain (in other words, its children); usually it contains a group, if you need to display multiple gadgets. A MUIC_Window object can have only one child.</p>
<p>As we previoulsy said, we must assign a MUIC_Application object to our window:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *app = MUI_NewObject(MUIC_Application,
                                MUIA_Application_Title  , <span class="st">&quot;ShInKy Tutorial GUI&quot;</span>,
                                MUIA_Application_Base  , <span class="st">&quot;ShInKyTutorialGUI&quot;</span>,
                                MUIA_Application_Description, <span class="st">&quot;MUI GUI Example&quot;</span>,
                                MUIA_Application_Window, window,
                            TAG_DONE);</code></pre>
<p>MUIA_Application_Title is used by the system as the application name which will be displayed to the user, while MUIA_Application_Base is the name used by the system to identify the application. MUIA_Application_Description is our application's description the system will provide to the user. Now you can make the window visible (in other words, open it) setting the MUIA_Window_Open attribute to TRUE, like this:</p>
<pre class="sourceCode c"><code class="sourceCode c">SetAttrs(window, MUIA_Window_Open, TRUE, TAG_DONE);</code></pre>
<p>We should mention that a MUIC_Window object exists only in the context of a MUIC_Application object, this means that you cannot make your window visible until you add it to your application object, otherwise you will get a crash.</p>
<p>We started building the graphical interface from the innermost to the outermost element, avoiding passing a NULL pointer to the above mentioned MUIA_Group_Child, MUIA_Window_RootObject and MUIA_Application_Window attributes. It's time to go back to the rootclass' OM_ADDMEMBER method we have previously described (4.3.2), which allows us to build our interface as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *app = MUI_NewObject(MUIC_Application,
                                MUIA_Application_Title  , <span class="st">&quot;ShInKyButton&quot;</span>,
                                MUIA_Application_Base  , <span class="st">&quot;ShInKyButton&quot;</span>,
                            TAG_DONE);

Object *group = MUI_NewObject(MUIC_Group, TAG_DONE);


Object *string = MUI_NewObject(MUIC_String, 
                                    MUIA_Frame, MUIV_Frame_String,
                                    MUIA_String_Contents,(IPTR) <span class="st">&quot;Click the button...&quot;</span>,
                                TAG_DONE);
        
Object *button= MUI_MakeObject(MUIO_Button, <span class="st">&quot;Click me!&quot;</span>);

DoMethod(group, OM_ADDMEMBER, string);
DoMethod(group, OM_ADDMEMBER, button);

Object *window = MUI_NewObject(MUIC_Window,
                                     MUIA_Window_Title, <span class="st">&quot;My Window&quot;</span>,
                                     MUIA_Window_ID ,MAKE_ID(&#39;M&#39;,&#39;a&#39;,&#39;i&#39;,&#39;n&#39;),
                                     MUIA_Window_RootObject, group,
                                 TAG_DONE);


DoMethod(app, OM_ADDMEMBER, window);</code></pre>
<p>Using this method we can add children objects to other objects after their instantiation. If, for example, we want to remove our window from the app object, we will write the following steps:</p>
<pre class="sourceCode c"><code class="sourceCode c">SetAttrs(window, MUIA_Window_Open, FALSE, TAG_DONE); <span class="co">/* close the window;*/</span>

DoMethod(app, OM_REMMEMBER, window); <span class="co">/* remove the window object         */</span>
                                     <span class="co">/* from the application object;     */</span></code></pre>
<p>If we want to add MUIC_Group objects to a window we must close it first, while if we want to add or remove objects from a MUIC_Group instance, we must explicitly notify these actions to MUI. To do this, we must surround the code (in which we will perform the removal or addition of elements in the group) with the MUIM_Group_InitChange method and notifying the end of the changes invoking the MUIM_Group_ExitChange method:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(group, MUIM_Group_InitChange);
.
.
.
<span class="co">/*changes*/</span>
.
.
.
DoMethod(group, MUIM_Group_ExitChange);</code></pre>
<p>Feel free to decide about the creation and removal of objects according to your needs.</p>
<h2 id="mui-notifications">4.5 MUI: Notifications</h2>
<p>In 4.4 we talked about the notification concept. A GUI item can react to a user triggered event, performing an action that can involve other graphical objects. Following the example in the previous paragraph, now we want the content of the string and the button to react when we click the button. To do so, MUI employs the MUIM_Notify method of the class with the same name; since almost alla MUI classes are children of MUIC_Notify, all our instances can use the MUI notification system. MUIM_Notify method can be used with three different techniques: an AmigaOS standard called &quot;callback hook&quot;, a notification through methods inside our private classes, or using notificable attributes. For the time being, we will deal with the first technique, we will see the other (more OOP compliants) later.</p>
<h3 id="mui-notifications-with-callback-hook">4.5.1 MUI: Notifications with callback hook</h3>
<p>The philosophy behind the callback hook involves the extension of a module (a library, a device, a class, etc...) by hooking new functions. To obtain this, a new function is hooked to a module using a structure called Hook. The Hook structure is different in the various AmigaOS flavours, so to keep compatibility, we will use the SDI tools (see Chap 1), specifically a header called SDI_hook.h. In practice, using SDI_hook.h, we can build the function to hook and its relative hook in this way:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*Function to hook*/</span>
HOOKPROTO(NameOfTheFunction, 
          ReturnValue,
          ObjectToHandle,
          ParametersToReceive);
{
....
}
<span class="co">/*Hook to be used*/</span>
MakeHook(HookName, NameOfTheFunction);</code></pre>
<p>SDI_hook.h allows us to choose between different ways to create functions and to create hooks. We suggest reading this header for further details.</p>
<p>Following the example in the previous paragraph, we first write the hookPutVal() function able to perform the change of the attributes of the button and the string objects, then the relative Hook called buttonHook:</p>
<pre class="sourceCode c"><code class="sourceCode c">HOOKPROTONO(hookPutVal, <span class="dt">void</span>, APTR *data)
{

  Object *button, *string;
  
  button=(Object *) *data++;
  string=(Object *) *data; 
    
  SetAttrs(string, 
           MUIA_String_Contents,
           (IPTR) <span class="st">&quot;Button clicked!&quot;</span>,
           TAG_DONE);
     
  SetAttrs(button, 
           MUIA_Text_Contents,
           (IPTR) <span class="st">&quot;Clicked!&quot;</span>,
           TAG_DONE);
     
  SetAttrs(button, 
           MUIA_Disabled,
           TRUE,
           TAG_DONE);  
}
MakeStaticHook(buttonHook,hookPutVal); </code></pre>
<p>As you can see in the function declaration, we are using the &quot;NO&quot; variant provided by SDI_hook.h that allows us avoiding the parameter representing the object to be manipulated; actually in this case we are dealing not only with one object, but two. These objects are passed by address, more precisely the &quot;data&quot; variable contains the parameters received by the invoked function, whose first parameter passed with data is the hook address. To obtain the address of the first object passed to the function after the hook, we cast to (Object *) the pointer. We proceed incrementing the pointer position to retrieve the following objects; in this case we only have a button and a string. Now we got all the data we need to handle MUI objects: we can proceed to the three SetAttrs() calls, the first of them will set the text &quot;Button clicked!&quot; inside our MUIC_String object, the second call changes the text inside the button and the third disables the button. The hooking of the function to an object is made by the MUIM_CallHook method, through MUIM_Notify:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(button,  MUIM_Notify, 
                  MUIA_Pressed, FALSE,
                  MUIV_Notify_Self,
                  <span class="dv">4</span>,
                  MUIM_CallHook,
                  &amp;buttonHook,
                  button,
                  string);</code></pre>
<p>Invoking MUIM_Notify through a DoMethod() function call will bind a notification to an object. This method takes the following parameters:</p>
<ul>
<li>the object that will activate a notification;</li>
<li>the attribute of the object to be checked in order to activate a notification;</li>
<li>the object on which the notification method will be executed;</li>
<li>the number of parameters passed to the notification method;</li>
<li>the notification method;</li>
<li>the parameteres, if any;</li>
</ul>
<p>In our example:</p>
<ul>
<li>MUIM_Notify is the method that will be invoked on the button click event;</li>
<li>MUIA_Pressed is the attribute that will be checked to be FALSE, that means the notification will be triggered on release of the button after being pressed;</li>
<li>The notification method must be applied to the button itself (MUIV_Notify_Self);</li>
<li>The number of parameters for the notification method: 4;</li>
<li>The notification method: MUIM_CallHook;</li>
</ul>
<p>To be honest, the number &quot;4&quot; indicates how many parameters will be after the MUIV_Notify_Self value. Obviously, the programmer must know the number of parameters that will be passed to the hook function; a wrong number of parameters specified here could lead to a disaster later inside the hook due to the pointer arithmetic we previously explained.</p>
<p>The value MUIV_Notify_Self is used to decide whether to trigger the notification method, in our case MUIM_CallHook. MUIM_Notify takes these decisions using a predeclared value in the MUI system. Generally, a MUI value is identified by the &quot;MUIV_&quot; prefix, in the MUIV_Notify case we can choose from:</p>
<ul>
<li>MUIV_Notify_Self: the object itself on which the MUIM_Notify method is called;</li>
<li>MUIV_Notify_Window: the MUIC_Window instance that contains the object;</li>
<li>MUIV_Notify_Application: the MUIC_Application instance that contains the object's mother window;</li>
<li>MUIV_Notify_Parent: the object's parent instance;</li>
</ul>
<p>The MUIM_CallHook method calls a function through the relative hook, in our case &quot;buttonHook&quot;, whose hooked function hookPutVal() receives button and string as parameters.</p>
<h3 id="mui-window-closing-and-the-old-notify-method-with-returnid">4.5.2 MUI: window closing and the old notify method with ReturnID</h3>
<p>Even the close gadget at the top of the window managing the application exit is handled by the MUIM_Notify method. Following the example in the previous paragraph, our window object is handled as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(window, MUIM_Notify, 
                   MUIA_Window_CloseRequest, TRUE,
                   MUIV_Notify_Application,
                   <span class="dv">2</span>,
                   MUIM_Application_ReturnID,
                   MUIV_Application_ReturnID_Quit);</code></pre>
<p>We are declaring that when the MUIA_Window_CloseRequester turns to TRUE (the user clicks the window close gadget), the method MUIM_Application_ReturnID must be triggered on the MUIC_Application instance (identified by MUIV_NotifyApplication), passing a MUIV_Application_ReturnID_Quit value.</p>
<p>MUIM_Application_ReturnID is a method that &quot;forces&quot; the MUIM_Application_(New)Input method to return a value, in our case the next call to MUIM_Application_Input will return MUIV_Application_ReturnID_Quit.</p>
<p>MUIM_Application_Input is a method, now deprecated, used to catch all the return values associated to user inputs on a MUI application. This involved the use of a big control cycle, in which every return value of a MUI interface was checked. This technique is the same of the &quot;pure&quot; BOOPSI programming and assigns the input controlling to the application itself. Even though in some situations this kind of handling can be avoided, using Reaction classes, on &quot;pure&quot; BOOPSI a big control cicle is the standard way of handling inputs. MUI keeps a similar method for backward compatibility with older applications and only to handle the close gadget of the window. More precisely, a faster version of MUIM_ApplicationInput is used for this goal, called MUIM_Application_NewInput; actually, we will invoke MUIM_Application_ReturnID with:</p>
<pre class="sourceCode c"><code class="sourceCode c">IPTR sigs = <span class="dv">0</span>;
<span class="kw">while</span> (DoMethod(app, MUIM_Application_NewInput, (IPTR)&amp;sigs) != MUIV_Application_ReturnID_Quit)
{
  ;
}</code></pre>
<p>Basically we check that MUIM_Application_NewInput returns a value different in the sigs variable from MUIV_Application_ReturnID_Quit. Otherwise the loop will exit, allowing the application to follow closing operations. Is a common practice to add a check for the interrupt signal CTRL+C inside that loop, in order to catch the CTRL+C signal when the application is launched from the command line (the Shell).</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">while</span> (DoMethod(app, MUIM_Application_NewInput, (IPTR)&amp;sigs) != MUIV_Application_ReturnID_Quit)
{
  <span class="kw">if</span> (sigs)
  {
    sigs = Wait(sigs | SIGBREAKF_CTRL_C);
    <span class="kw">if</span> (sigs &amp; SIGBREAKF_CTRL_C) <span class="kw">break</span>;
  }
}</code></pre>
<p>To learn about the Wait() function and the SIGBREAKF_CTRL_C see paragraph 5.1</p>
<h3 id="zune-and-muim_application_execute">4.5.3 Zune and MUIM_Application_Execute</h3>
<p>In the previous paragraph we described a while loop to check for the application closing signal, usually called the &quot;main loop&quot;. Zune offers the programmer the chance to avoid the loop, leaving the closing task to a new method, MUIM_Application_Execute. Basically this method hides the use of the main loop from the programmer, making everything look more readable and modern. Its syntax is simply:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(app, MUIM_Application_Execute);</code></pre>
<p>We leave to the reader the implementation of a portable MUIM_Application_Execute method. Informations useful for such implementation will be explained later.</p>
<h2 id="at-the-heart-of-a-boopsimui-class-the-dispatcher">4.6 At the heart of a BOOPSI/MUI class: the Dispatcher</h2>
<p>Up until now we just created instances of classes already available, without knowing how to create our own. Object-Oriented Programming (OOP) serves the purpose of creating highly modular applications. Following the rules of OOP, developers create also software modules that can be used again in different contexts, and MUI programming is no exception.</p>
<p>The engine behind a BOOPSI (and MUI) class that makes it an active module is a peculiar function called dispatcher. When a BOOPSI object receives a message, the dispatcher checks the message in order to verify if the receiver is able to handle its parameters (the message itself). In other words every Intuition and MUI function we've talked about until now use the dispatcher. A BOOPSI object, in the end, is nothing but a plain C structure and it could not perform any action without a dispatcher.</p>
<p>Now we know that each BOOPSI class has a parent class; this relationship goes up until the rootclass. Each class has its own dispatcher function. If the class dispatcher does not recognize a parameter received, it will push the unknown parameter to the parent class. This could happen up until the rootclass itself that, in this case, would return an error message.</p>
<p>In other words, the dispatcher is the function that invokes the class methods it belongs to, choosing which one is appropriate for that message. The dispatcher could implement itself the code to manage the message or invoke the corresponding class method. Also, the declaration and the definition of a dispatcher changes depending on which Amiga flavour we are working. Luckily the SDI Tools will help us again providing two macros, again in sdi_hook.h, called DISPATCHERPROTO() and DISPATCHER(). DISPATCHERPROTO() is the macro used to declare the dispatcher prototype and accepts just one argument, the name of our dispatcher:</p>
<pre class="sourceCode c"><code class="sourceCode c">DISPATCHERPROTO(MyDispatcher);</code></pre>
<p>With the DISPATCHER() macro we define the real function:</p>
<pre class="sourceCode c"><code class="sourceCode c">DISPATCHER(MyDispatcher)
{
  <span class="kw">switch</span> (msg-&gt;MethodID)
  {
    <span class="kw">case</span> OM_NEW : <span class="kw">return</span> myNew(cl,obj,(APTR)msg);
  }

  <span class="kw">return</span> DoSuperMethodA(cl,obj,msg);
}</code></pre>
<p>In this example the dispatcher only takes care of managing the OM_NEW method of its class, invoking a myNew() function that will be described later. After having managed (if needed) OM_NEW, the dispatcher sends the message to the rootclass, using the DoSuperMethodA() of Intuition. The parameters &quot;cl&quot;, &quot;obj&quot; and &quot;msg&quot;, were received by the dispatcher itself. The prototype of the dispatcher, on any Amiga-ish incarnation, needs these three parameters. &quot;cl&quot; is the class the dispatcher belongs to, &quot;obj&quot; is the object that has received the message and &quot;msg&quot; is the message itself, &quot;opSet&quot; in our example (see paragraph 4.3).</p>
<h3 id="implementation-of-a-mui-private-class">4.6.1 Implementation of a MUI private class</h3>
<p>OOP's strength lies on the possibility to let the programmer write his/her own classes and use them again in different contexts. For example, if we would like to subclass MUIC_Group, creating a subclass containing the two objects of paragraph 4.5 (the button and the string), first of all we should declare a private data area (a simple struct) of our new class:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> myDataArea
{    
   Object *button, *string;
   STRPTR labelButton, labelStr;
};</code></pre>
<p>Now, according to BOOPSI rules variables declared inside the data area will be later recognized as private attributes of the class.</p>
<p>Speaking of methods, a MUI class provides implementation of the following methods:</p>
<pre><code>- OM_NEW;
--- MUIM_Setup;
--- MUIM_AskMinMax;
------ MUIM_Show;
--------- MUIM_Draw;
------ MUIM_Hide;
--- MUIM_Cleanup;
- OM_DISPOSE;</code></pre>
<p>Each method will be implemented only if really needed. For the moment we will explain only how to implement the OM_NEW method.</p>
<h3 id="implementing-om_new-and-its-external-tags">4.6.2 Implementing OM_NEW and its external tags</h3>
<p>Looking at the sample dispatcher in paragraph 4.5.2, a possible definition of a myNew() function (which will represent OM_NEW method implementation) could be:</p>
<pre class="sourceCode c"><code class="sourceCode c">IPTR myNew(<span class="kw">struct</span> IClass *cl,Object *obj,<span class="kw">struct</span> opSet *msg)
{
  <span class="kw">struct</span> myDataArea *data;
  .
  .
  .
  .
  <span class="co">/*call to method OM_NEW of superclass*/</span>
  .
  .
  .

  data = INST_DATA(cl,obj);
  
  .
  .
  .
  .
  <span class="co">/*return pointer to istantiated object*/</span>   
}</code></pre>
<p>A function in charge of implementing OM_NEW will always have this signature: &quot;cl&quot; is the class the dispatcher belongs to, &quot;obj&quot; is the object that has received the message, &quot;msg&quot; is the message. INST_DATA() is a macro used to get a pointer to the private data area of the caller object.</p>
<p>The data area of our class is nothing but the struct we declared before and the other superclasses' data areas (polymorphism), if any. Allocation of the superclass data area happens when the OM_NEW method of the superclass is invoked. This process repeats and goes up until the rootclass. The OM_NEW method of the rootclass will now allocate enough memory for its own data area, passing the pointer to the subclass: this is how an instance of the rootclass is created. The subclass, upon receiving the rootclass object, will use the INST_DATA() macro to tell the system to allocate more memory to be added to the superclass data area (identified by the rootclass pointer), and then populate it with its own data area. After that, and after having executed other actions (if any), the OM_NEW method of said class will send this data area to the subclass, again using a pointer to the instanced object. Each class performs these actions until our OM_NEW method is reached, which - again - will perform these actions, again through the INST_DATA() macro.</p>
<p>Before invoking the OM_NEW method of the superclass, we may want to read parameters (a message, that is) - if any are existing - passed to our method. In our example, if we want to inizialize the values of labelButton and labelStr from our OM_NEW overload method, we should associate these variables to labels (ID) that our method will recognize. Here's how to declare such IDs:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define MUI_CLASS_TUTORIAL (TAG_USER | 0x80420000)</span>
<span class="ot">#define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1</span>
<span class="ot">#define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2</span></code></pre>
<p>Here we have defined three symbols, the location of the last two of them depending on the first. MUI_CLASS_TUTORIAL is the first defined symbol and his value is given by a bitwise OR on TAG_USER (a system value used to separate user tags from system tags) and the hexadecimal value 0x80420000. This hex value is not randomly choosen: MUI documentation, in fact, recommend using hex values in the range 0x80420000 - 0x80429999 for public attributes of your own classes.</p>
<p>Actually, if we are creating private classes, not reachable by other tasks othen than our own, we could define these symbols as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define MUIA_MUIClassTutorial_TextStr  TAG_USER + 20</span>
<span class="ot">#define MUIA_MUIClassTutorial_LabelBut TAG_USER + 21#</span></code></pre>
<p>and so on...</p>
<p>Remember to use values not too close to TAG_USER, otherwise in some conditions weird behaviour could arise.</p>
<p>Now we should analyze the message received, checking whether he user has possibly sent initialization code for labelButton and labelStr:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *string, *button;        <span class="co">/*we alloc objects which later will*/</span>
STRPTR labelStr, labelButton;   <span class="co">/*populate our data area*/</span>

{<span class="co">/*block for tag list reading*/</span>
  <span class="kw">struct</span> TagItem *tags, *tag;

  tags=((<span class="kw">struct</span> opSet *)msg)-&gt;ops_AttrList;
  <span class="kw">while</span> (tag=NextTagItem(&amp;tags))
  {
    <span class="kw">switch</span> (tag-&gt;ti_Tag)
    {
      <span class="kw">case</span> MUIA_MUIClassTutorial_TextStr:
      <span class="kw">if</span> (tag-&gt;ti_Data)
        labelStr= (STRPTR) tag-&gt;ti_Data;
      <span class="kw">break</span>;
      
      <span class="kw">case</span> MUIA_MUIClassTutorial_LabelBut:
      <span class="kw">if</span> (tag-&gt;ti_Data)
        labelButton= (STRPTR) tag-&gt;ti_Data;
      <span class="kw">break</span>;
    }
  }
}</code></pre>
<p>As we know, the opSet message (see paragraph 4.3) has a variable ops_AttrList pointing to the passed taglist. This is why we have declared two pointers (tags and tag), they will be used while iterating through the list using NextTagItem() function from utility.library. Each call to NextTagItem() pops the current item from the list into the tag variable. Using a switch we check the value of tag-&gt;ti_Tag of the current item against the values we have declared before: if tag-&gt;ti_Tag equals MUIA_MUIClassTutorial_TextStr, for example, labelStr will be initialized to the value from tag-&gt;ti_Data, while if tag-&gt;ti_Tag equals MUIA_MUIClassTutorial_LabelBut, the value in tag-&gt;ti_Data will be put into labelBtn.</p>
<p>It's important to notice how the declaration of NextTagItem() on AROS is slightly different than other Amiga-ish operating systtems; for this reason the above mentioned code could emit warnings when compiled. In order to solve this issue, we can define our own TAGITEM define:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifdef __AROS__</span>
  <span class="ot">#define TAGITEM const struct TagItem **</span>
<span class="ot">#else</span>
  <span class="ot">#define TAGITEM  struct TagItem **</span>
<span class="ot">#endif  </span></code></pre>
<p>and use it to cast the value returned:</p>
<pre class="sourceCode c"><code class="sourceCode c">...
 <span class="kw">while</span> (tag=NextTagItem((TAGITEM)&amp;tags))
...</code></pre>
<p>It's common practice using such a syntax (NextTagItem() associated with a switch) when implementing the OM_SET method when there are a lot of attributes to manage. It is possible to make the code more compact by using the shortcuts GetTagData() from utility.library:</p>
<pre class="sourceCode c"><code class="sourceCode c">IPTR GetTagData(Tag,IPTR,<span class="kw">struct</span> TagItem *);</code></pre>
<p>This function requires the tag to be used as first argument, a default return value if the label is not found as second argument and the already mentioned ops_AttrList as last argument. Replacing the switch with GetTagData() is described below:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> TagItem *tags;
tags=((<span class="kw">struct</span> opSet *)msg)-&gt;ops_AttrList;

labelStr = (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)NULL, tags);
      
labelButton = (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)NULL, tags);      </code></pre>
<p>We have mentioned there could be an attribute not managed by the OM_NEW method we are overloading. Such an attribute must be handled by the superclass' OM_NEW (which will be invoked anyway, also to solve this kind of issues).</p>
<p>At this stage we should istantiate the label and button objects, just like we did before (see paragraph 4.4.2) and initialize them with the labelStr and labelButton values.</p>
<p>In order to call the superclass' OM_NEW method we can either use DoSuperMethodA() or its variadic version DoSuperMethod():</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> TagItem taglist[] = {{MUIA_Group_Child, (IPTR) string},
                            {MUIA_Group_Child,(IPTR) button},
                            {TAG_MORE, (IPTR) msg-&gt;ops_AttrList}};

obj =(Object *) DoSuperMethod(cl, 
                              obj,
                              OM_NEW,
                              taglist,
                              NULL);
            
<span class="kw">if</span> (obj==NULL)
    <span class="kw">return</span> <span class="dv">0</span>;</code></pre>
<p>With DoSuperMethod() we invoke the superclass', in our example MUIC_Group, OM_NEW method passing a tag list that will let the method create a group with our string and our label as children. TAG_MORE signals the presence of a new taglist which pointer - as we know - is found in tag-&gt;ops_AttrList. If DoSuperMethod() returns NULL it means the arguments passed were not recognized by the superclass' method. This syntax is a bit tedious, so it is common practice using the utility function DoSuperNew(), which we will better explain later. Suffice to say for the moment that this function can replace the above code with the following:</p>
<pre class="sourceCode c"><code class="sourceCode c">obj = DoSuperNew(cl, 
                 obj,
                 MUIA_Group_Child, string,
                 MUIA_Group_Child, button,
                 TAG_MORE, msg-&gt;ops_AttrList);

<span class="kw">if</span> (obj==NULL)
  <span class="kw">return</span> <span class="dv">0</span>;</code></pre>
<p>With DoSuperNew() we passed the objects label and button to our superclass' OM_NEW method; these objects will become children of the next object we will instantiate. These objects will be automatically positioned inside the container object of MUIC_Group class and, with that, they will represent the instance of our private MUI class. Now there's only to invoke INST_DATA(), that will provide our own private data structure that will be populated as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c">data = INST_DATA(cl,obj);

data-&gt;labelStr    = labelStr;
data-&gt;labelButton = labelButton;
data-&gt;str         = string;
data-&gt;button      = button;

<span class="kw">return</span> obj;</code></pre>
<p>At this point we have shown all there's to do to implement the OM_NEW method.</p>
<h3 id="using-a-private-class">4.6.3 Using a private class</h3>
<p>After having implemented all that is needed in the previous paragraphs, we are now able to use our new MUI class. To do so, we use the method MUI_CustomClass() from MUImaster.library. The syntax is as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MUI_CustomClass *mcc;

mcc = (<span class="kw">struct</span> MUI_CustomClass *) MUI_CreateCustomClass(NULL,
                                                       MUIC_Group,
                                                       NULL,
                                                       <span class="kw">sizeof</span>(<span class="kw">struct</span> myDataArea),
                                                       ENTRY(MyDispatcher));</code></pre>
<p>The first parameter of this function call is NULL when dealing with private classes; it is only assigned if we are sharing a public MUI class, that's all we need to know at the moment. The second parameter is our class's superclass, from which it will inherit methods and attributes. The third parameter is only used if our subclass is daughter of another private class, so this parameter too is NULL in this case. The fourth parameter is the size of our private data struct. The fifth and last parameter is the dispatcher name. The ENTRY() macro, from the SDI tools, is used by MorphOS to tell a native PPC class from a 68K one; other compilers will ignore this macro. Using this macro allows us to be compatible with MorphOS.</p>
<p>Now, if the call to MUI_CreateCustomClass() succeded, we should have in &quot;mcc&quot; the instance of our private MUI class, to be used as a parameter for the Intuition method NewObject() as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object *MyObj; 

MyObj = (Object *) NewObject(mcc-&gt;mcc_Class, 
                             NULL,
                             MUIA_MUIClassTutorial_TextStr,(IPTR) <span class="st">&quot;Click the button...&quot;</span>,
                             MUIA_MUIClassTutorial_LabelBut,(IPTR) <span class="st">&quot;ClickMe!&quot;</span>,
                             TAG_DONE);</code></pre>
<p>As you can see in the above example, a MUI private class is identified by a MUI_CustomClass data structure that contains a pointer &quot;mcc_Class&quot; to a IClass struct (used to identify private BOOPSI classes). The official documentation recommends to not use the MUI_NewObject() function. With NewObject() - as we explained earlier - we are invoking the OM_NEW method of our class, and we are passing it the values for the attributes MUIA_MUIClassTutorial_TextStr and MUIA_MUIClassTutorial_LabelBut.</p>
<p>After having used our class, we must deallocate it from the memory:</p>
<pre class="sourceCode c"><code class="sourceCode c">MUI_DeleteCustomClass(mcc);</code></pre>
<p>this call must be put after the usual MUI_DisposeObject();</p>
<p>So, after inserting MUI_CreateCustomClass() in a special function, our code is now complete:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/****************************************************************************/</span>
<span class="co">//file sys.h</span>
<span class="co">/****************************************************************************/</span>
<span class="co">/* Includes */</span>
<span class="ot">#ifndef __SYS_INCLUDES__</span>
<span class="ot">#define __SYS_INCLUDES__</span>

<span class="ot">#include &lt;stdlib.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="ot">#include &lt;proto/exec.h&gt;</span>
<span class="ot">#include &lt;proto/dos.h&gt;</span>
<span class="ot">#include &lt;proto/utility.h&gt;</span>
<span class="ot">#include &lt;proto/intuition.h&gt;</span>

<span class="ot">#include &lt;proto/MUImaster.h&gt;</span>
<span class="ot">#include &lt;libraries/mui.h&gt;</span>

<span class="ot">#if !defined (__amigaos4__)</span>
<span class="ot">#include &lt;clib/alib_protos.h&gt;</span>
<span class="ot">#endif</span>
                
<span class="ot">#include &lt;SDI_compiler.h&gt;</span>
<span class="ot">#include &lt;SDI_hook.h&gt;</span>
<span class="ot">#include &lt;SDI_stdarg.h&gt;</span>


<span class="ot">#if !defined(__AROS__) || !defined(__MORPHOS__)</span>
<span class="ot">#ifdef __amigaos4__</span>
<span class="ot">#define IPTR uint32</span>
<span class="ot">#else</span>
<span class="ot">#define IPTR ULONG</span>
<span class="ot">#endif</span>
<span class="ot">#endif</span>

<span class="ot">#ifndef __AROS__</span>
<span class="ot">#define STACKED</span>
<span class="ot">#endif</span>

<span class="ot">#ifdef __AROS__</span>
    <span class="ot">#define TAGITEM const struct TagItem **</span>
<span class="ot">#else</span>
    <span class="ot">#define TAGITEM  struct TagItem **</span>
<span class="ot">#endif</span>

<span class="ot">#if !defined (__MORPHOS__)</span>
Object * VARARGS68K DoSuperNew(<span class="kw">struct</span> IClass *cl, Object *obj, ...);
<span class="ot">#endif</span>

<span class="ot">#endif   </span>
         
<span class="co">/****************************************************************************/</span>

<span class="co">/****************************************************************************/</span>
<span class="co">// file MUIClass.h</span>
<span class="co">/****************************************************************************/</span>

<span class="ot">#ifndef __MYMUICLASS__</span>
    <span class="ot">#define __MYMUICLASS__</span>

    <span class="ot">#define MUI_CLASS_TUTORIAL (TAG_USER | 0x80420000&lt;&lt;16)</span>

    <span class="ot">#define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1</span>
    <span class="ot">#define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2</span>

    <span class="kw">struct</span> MUI_CustomClass *initMUIClass();
<span class="ot">#endif    </span>
<span class="co">/****************************************************************************/</span>

<span class="co">/****************************************************************************/</span>
<span class="co">//file MUIClass.c</span>
<span class="co">/***************************************************************************/</span>

<span class="ot">#include &quot;sys.h&quot;</span>
<span class="ot">#include &quot;MUIClass.h&quot;</span>

<span class="kw">struct</span> MyData
{
    Object *button, *str;
    STRPTR labelButton, labelStr;
};


<span class="co">///hookPutVal</span>
HOOKPROTONO(hookPutVal, <span class="dt">void</span>,APTR *data)
{
    Object *bt_1, *str;
        
    bt_1=(Object *) *data++;
    str=(Object *) *data;
                
    SetAttrs(str, MUIA_String_Contents,(IPTR) <span class="st">&quot;Clicked button...&quot;</span>, TAG_DONE);
    SetAttrs(bt_1, MUIA_Text_Contents,(IPTR) <span class="st">&quot;Clicked!&quot;</span>, TAG_DONE);
    SetAttrs(bt_1, MUIA_Disabled, TRUE, TAG_DONE);    
}
MakeStaticHook(buttonHook, hookPutVal);
<span class="co">///</span>

<span class="co">///OM_NEW()</span>
IPTR mNew(<span class="kw">struct</span> IClass *cl, Object *obj, <span class="kw">struct</span> opSet *msg)
{
    <span class="kw">struct</span> MyData *data;
        
    STRPTR labelStr, labelButton;
    Object *str, *button;
    <span class="kw">struct</span> TagItem *tags;

    tags=((<span class="kw">struct</span> opSet *)msg)-&gt;ops_AttrList;

    labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)<span class="st">&quot; &quot;</span>,tags);

    labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)<span class="st">&quot; &quot;</span>,tags);

        
    str = MUI_NewObject(MUIC_String,
                            MUIA_Frame, MUIV_Frame_String,
                            MUIA_String_Contents,(IPTR) labelStr,
                        TAG_DONE);
        
    button= (Object *) MUI_MakeObject(MUIO_Button,(IPTR) labelButton, TAG_DONE);
                                        
    obj = (Object *) DoSuperNew(cl, obj,
                                    MUIA_Group_Child, str,
                                    MUIA_Group_Child, button,
                                TAG_MORE, msg-&gt;ops_AttrList);

    <span class="kw">if</span> (obj==NULL)
        <span class="kw">return</span> <span class="dv">0</span>;

    data = (<span class="kw">struct</span> MyData *) INST_DATA(cl,obj);

    data-&gt;str= str;
    data-&gt;button=  button;
    data-&gt;labelStr= labelStr;
    data-&gt;labelButton=  labelButton;

    DoMethod(data-&gt;button, MUIM_Notify,
             MUIA_Pressed, FALSE,
             MUIV_Notify_Self, <span class="dv">4</span>,
             MUIM_CallHook,
             &amp;buttonHook,
             data-&gt;button,
             data-&gt;str);
                         
    <span class="kw">return</span> (IPTR)obj;
}
<span class="co">///</span>

<span class="co">///MyDispatcher</span>
DISPATCHER(MyDispatcher)
{
    <span class="kw">switch</span> (msg-&gt;MethodID)
    {
        <span class="kw">case</span> OM_NEW : 
            <span class="kw">return</span> mNew(cl,obj,(<span class="kw">struct</span> opSet *)msg);
    }

    <span class="kw">return</span>(DoSuperMethodA(cl,obj,msg));
}
<span class="co">///</span>

<span class="kw">struct</span> MUI_CustomClass *initMUIClass()
{
    <span class="kw">return</span> (MUI_CreateCustomClass(NULL, MUIC_Group, NULL, <span class="kw">sizeof</span>(<span class="kw">struct</span> MyData), ENTRY(MyDispatcher)));
}
                                                                                                 
<span class="co">/****************************************************************************/</span>

<span class="co">/****************************************************************************/</span>
<span class="co">//file main.c</span>
<span class="co">/****************************************************************************/</span>
<span class="ot">#include &quot;sys.h&quot;</span>
<span class="ot">#include &quot;MUIClass.h&quot;</span>

<span class="ot">#ifdef __MORPHOS__</span>
    <span class="kw">struct</span> Library *UtilityBase;
<span class="ot">#else</span>
    <span class="kw">struct</span> UtilityBase *UtilityBase;
<span class="ot">#endif</span>

<span class="kw">struct</span> IntuitionBase *IntuitionBase;
<span class="kw">struct</span> Library *MUIMasterBase;

<span class="ot">#ifdef __amigaos4__</span>
    <span class="kw">struct</span> UtilityIFace *IUtility;
    <span class="kw">struct</span> IntuitionIFace *IIntuition;
    <span class="kw">struct</span> MUIMasterIFace *IMUIMaster;
<span class="ot">#endif</span>

<span class="kw">struct</span> MUI_CustomClass *mcc;

<span class="co">///fail()</span>
<span class="dt">void</span> fail(Object *app, STRPTR notice_txt)
{
    <span class="kw">struct</span> EasyStruct requester;
        
    <span class="kw">if</span> (app)
        MUI_DisposeObject(app);

<span class="ot">#ifdef __amigaos4__</span>
    <span class="kw">if</span> (IMUIMaster)
        DropInterface((<span class="kw">struct</span> Interface *)IMUIMaster);
        
    <span class="kw">if</span> (IIntuition)
        DropInterface((<span class="kw">struct</span> Interface *)IIntuition);
        
    <span class="kw">if</span> (IUtility)
        DropInterface((<span class="kw">struct</span> Interface *)IUtility);
<span class="ot">#endif</span>

    <span class="kw">if</span> (MUIMasterBase)
        CloseLibrary((<span class="kw">struct</span> Library *)MUIMasterBase);

    <span class="kw">if</span> (IntuitionBase)
        CloseLibrary((<span class="kw">struct</span> Library *)IntuitionBase);

    <span class="kw">if</span> (UtilityBase)
        CloseLibrary((<span class="kw">struct</span> Library *)UtilityBase);


    requester.es_StructSize = <span class="kw">sizeof</span>(<span class="kw">struct</span> EasyStruct);
    requester.es_Flags      = <span class="dv">0</span>;
        
    <span class="kw">if</span> (notice_txt != NULL)
    {
        requester.es_Title        =  <span class="st">&quot;Startup Error&quot;</span>;
        requester.es_TextFormat =  notice_txt;
        requester.es_GadgetFormat =  <span class="st">&quot;Exit&quot;</span>;
        EasyRequestArgs(NULL, &amp;requester, NULL, NULL);
    }
    <span class="kw">else</span>
    {
        requester.es_Title        = <span class="st">&quot;Attention&quot;</span>;
        requester.es_TextFormat =  <span class="st">&quot;Closure completed successfully&quot;</span>;
        requester.es_GadgetFormat = <span class="st">&quot;Exit&quot;</span>;
        EasyRequestArgs(NULL, &amp;requester, NULL, NULL);
    }
}
<span class="co">///</span>

<span class="co">///init()</span>
<span class="dt">void</span> init(<span class="dt">void</span>)
{
    <span class="ot">#ifdef __MORPHOS__</span>
    <span class="kw">if</span> ( !(UtilityBase=(<span class="kw">struct</span> Library *) OpenLibrary(<span class="st">&quot;utility.library&quot;</span>,<span class="dv">39</span>)) )
    <span class="ot">#else</span>
    <span class="kw">if</span> ( !(UtilityBase=(<span class="kw">struct</span> UtilityBase *) OpenLibrary(<span class="st">&quot;utility.library&quot;</span>,<span class="dv">39</span>)) )
    <span class="ot">#endif</span>
    {
        fail(NULL, <span class="st">&quot;Problem! Failed to open</span><span class="ch">\n</span><span class="st"> utility.library&quot;</span>);
    }
    <span class="kw">else</span>
    {
    <span class="ot">#ifdef __amigaos4__</span>
        IUtility = (<span class="kw">struct</span> UtilityIFace *) GetInterface((<span class="kw">struct</span> Library *)UtilityBase, 
                                <span class="st">&quot;main&quot;</span>, 
                                <span class="dv">1</span>, 
                                NULL);
    <span class="ot">#endif        </span>
    }

    <span class="kw">if</span> ( !(IntuitionBase=(<span class="kw">struct</span> IntuitionBase *) OpenLibrary(<span class="st">&quot;intuition.library&quot;</span>,<span class="dv">39</span>)) )
    {
        fail(NULL, <span class="st">&quot;Problem! Failed to open</span><span class="ch">\n</span><span class="st"> intuition.library&quot;</span>);
    }
    <span class="kw">else</span>
    {
        <span class="ot">#ifdef __amigaos4__</span>
        IIntuition = (<span class="kw">struct</span> IntuitionIFace *) GetInterface((<span class="kw">struct</span> Library *)IntuitionBase, 
                                        <span class="st">&quot;main&quot;</span>, 
                                        <span class="dv">1</span>, 
                                        NULL);
        <span class="ot">#endif        </span>
    }

    <span class="kw">if</span> (!(MUIMasterBase = OpenLibrary(MUIMASTER_NAME,<span class="dv">19</span>)))
    {
        fail(NULL,<span class="st">&quot;Problem! Failed to open</span><span class="ch">\n</span><span class="st"> MUImaster.library&quot;</span> );
    }
    <span class="kw">else</span>
    {
        <span class="ot">#ifdef __amigaos4__</span>
        IMUIMaster = (<span class="kw">struct</span> MUIMasterIFace *) GetInterface(MUIMasterBase, 
                                        <span class="st">&quot;main&quot;</span>, 
                                        <span class="dv">1</span>, 
                                        NULL);
        <span class="ot">#endif        </span>
    }    
}
<span class="co">///</span>

<span class="co">///main() function                             </span>
<span class="dt">int</span> main(<span class="dt">int</span> argc,<span class="dt">char</span> *argv[])
{
    Object *MyObj, *window, *app;
    

    init();

    <span class="kw">if</span> (!(mcc = (<span class="kw">struct</span> MUI_CustomClass *) initMUIClass()))
    {
                        fail(NULL,<span class="st">&quot;Problem! Failed to create our class...&quot;</span>);
    }


    MyObj = (Object *) NewObject(mcc-&gt;mcc_Class, NULL,
                                    MUIA_MUIClassTutorial_TextStr,(ULONG) <span class="st">&quot;Click the button...&quot;</span>,
                                    MUIA_MUIClassTutorial_LabelBut,(ULONG) <span class="st">&quot;Click me!&quot;</span>,
                                 TAG_DONE);


    window = (Object *) MUI_NewObject(MUIC_Window,
                                        MUIA_Window_Title,(IPTR) <span class="st">&quot;My Window&quot;</span>,
                                        MUIA_Window_ID ,MAKE_ID(&#39;M&#39;,&#39;a&#39;,&#39;i&#39;,&#39;n&#39;),
                                        MUIA_Window_RootObject, (IPTR) MyObj,
                                      TAG_DONE);
                                        

     app = (Object *) MUI_NewObject(MUIC_Application,
                                        MUIA_Application_Title      ,(IPTR)  <span class="st">&quot;MuiPortableClass&quot;</span>,
                                        MUIA_Application_Version    ,(IPTR)  <span class="st">&quot;$VER: MuiPortableClass 1.0&quot;</span>,
                                        MUIA_Application_Copyright  ,(IPTR)  <span class="st">&quot; &quot;</span>,
                                        MUIA_Application_Author     ,(IPTR)  <span class="st">&quot;ShInKurO&quot;</span>,
                                        MUIA_Application_Description,(IPTR)  <span class="st">&quot;Portable MUI class&quot;</span>,
                                        MUIA_Application_Base       ,(IPTR)  <span class="st">&quot;MuiPortableClass&quot;</span>,
                                        MUIA_Application_Window, (IPTR) window,
                                       TAG_DONE);
                                        
     

    <span class="kw">if</span> (!app)
        fail(app, <span class="st">&quot;Problem! Failed to create app&quot;</span>);

    DoMethod(window, 
                MUIM_Notify,
                MUIA_Window_CloseRequest,
                TRUE,
                app,
                <span class="dv">2</span>,
                MUIM_Application_ReturnID,
                MUIV_Application_ReturnID_Quit);

    
    SetAttrs(window, MUIA_Window_Open, TRUE, TAG_DONE);
                
    {<span class="co">/*main loop*/</span>
        IPTR sigs = <span class="dv">0</span>;
        <span class="kw">while</span> (DoMethod(app, MUIM_Application_NewInput, &amp;sigs) != MUIV_Application_ReturnID_Quit)
        {
            <span class="kw">if</span> (sigs)
            {
                sigs = Wait(sigs | SIGBREAKF_CTRL_C);
                <span class="kw">if</span> (sigs &amp; SIGBREAKF_CTRL_C) <span class="kw">break</span>;
            }
        }
    }

    SetAttrs(window, MUIA_Window_Open,FALSE,TAG_DONE);


    DisposeObject(app);     
    MUI_DeleteCustomClass(mcc);
    fail(NULL, NULL);          

    <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="co">///  </span>
<span class="co">/****************************************************************************/</span></code></pre>
<h2 id="dosupernew-and-variadic-functions">4.7 DoSuperNew() and variadic functions</h2>
<p>DoSuperNew() belongs to the utility functions of MorphOS and allows the programmer to simplify the creation of methods of new BOOPSI and MUI subclasses. Obviously, as tradition imposes, DoSuperNew() is not present in other systems, but then again the SDI Tools authors have put an &quot;indirect&quot; implementation of this function that employs such headers. The implementation uses the SDI_stdarg.h and SDI_compiler.h headers. Proceed as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c">Object * VARARGS68K DoSuperNew(<span class="kw">struct</span> IClass *cl, Object *obj, ...)
{
  Object *rc;
  VA_LIST args;

  VA_START(args, obj);
  rc = (Object *)DoSuperMethod(cl, obj, OM_NEW, VA_ARG(args, IPTR), NULL);
  VA_END(args);

  <span class="kw">return</span> rc;
} </code></pre>
<p>The VARARGS68K macro (located in the declaration of the function) finds its origin on AmigaOS4 and its purpose is to indicate the OS4 compiler to manage the variable number of parameters just like it would be done on AmigaOS3.x. Other compilers, thanks to the SDI_compiler.h, can safely ignore the VARARGS68K macro. The macros VA_LIST, VA_START(), VA_ARG() and VA_END() matches respectively va_list, va_start(), va_arg() and va_end() from the stdarg.h library and have been &quot;reimplemented&quot; in SDI_stdarg.h so to have a common standard for all the Amiga variations (they implement the standard ANSI variadic functions differently).</p>
<h2 id="mui-notification-performed-using-public-methods-of-private-classes">4.8 MUI: notification performed using public methods of private classes</h2>
<p>After showing the main concepts of a private class creation, we can now introduce the second model to manage the notifications that we mentioned before (paragraph 4.5).</p>
<p>First of all it's good to underline the fact that the previous method of notification employing callbacks hook, under certain circumnstances, could not respect one the main rules of OOP, the encapsulation, based on the concept of information hiding. In other words, a class should be a black box (which contents are mostly unknown) that provides services to the user. However, using hooks and a function connected it is possible to change from outside the attributes os a class considered private, simply passing them to the hook. Using hooks implies using the arithmethic of pointers, which can easily lead to errors. In order to avoid these issues and respect the OOP paradigm, it is possible to manage notifications using public methods belonging to our private class. A method belonging to a class will obviously operate with the class private data area (the attributes of said class, that is).</p>
<p>It's also good to remind how in the OOP paradigm a class method is invoked through a message; in a BOOPSI and MUI world we know that the message is a struct containing the ID of the method and possibly additional parameters. Let's pick again the example of paragraph 4.5 where we had a string and a button and we wanted to change their values when the user clicks the button. First of all let's declare the ID of our new public method:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define MUIM_MUIClassTutorial_ClickBut MUI_CLASS_TUTORIAL + 20</span></code></pre>
<p>Now let's declare the method's message:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MUIMP_MUIClassTutorial_ClickBut
{
  STACKED ULONG  MethodID;
};</code></pre>
<p>In this case the message will only contain its initialization method; in our example we don't need anything else as the method needs to work with internal class data. The function that will be associated to the MUIM_MUIClassTutorial_ClickBut method is nothing but a modified version of the previous &quot;hookPutVal&quot; function. More precisely, using the callback we had:</p>
<pre class="sourceCode c"><code class="sourceCode c">HOOKPROTONO(hookPutVal, <span class="dt">void</span>, APTR *data)
{

  Object *button, *string;

  button=(Object *) *data++;
  string=(Object *) *data;

  .
  .
  .

}
MakeStaticHook(buttonHook,hookPutVal);</code></pre>
<p>now we have a function like that:</p>
<pre class="sourceCode c"><code class="sourceCode c">IPTR mClickBut(<span class="kw">struct</span> IClass *cl, Object *obj, <span class="kw">struct</span> MUIMP_MUIClassTutorial_ClickBut *msg)
{

  <span class="kw">struct</span> MyData *data;
  data = (<span class="kw">struct</span> MyData *) INST_DATA(cl,obj);
  Object *bt_1, *str;

  bt_1=(Object *) data-&gt;button;
  str=(Object *)  data-&gt;str;

  .
  .
  .

  <span class="kw">return</span> (IPTR) obj;
}</code></pre>
<p>The difference between the two is apparent. We don't have an explicit use of pointer arithmetic and our function looks exactly like a class method. The dispatcher of our private class will now associate the mClickBut() function the MUIM_MUIClassTutorial_ClickBut ID:</p>
<pre class="sourceCode c"><code class="sourceCode c">DISPATCHER(MyDispatcher)
{
  <span class="kw">switch</span> (msg-&gt;MethodID)
  {
    <span class="kw">case</span> OM_NEW :
    <span class="kw">return</span> mNew(cl,obj,(<span class="kw">struct</span> opSet *)msg);

    <span class="kw">case</span> MUIM_MUIClassTutorial_ClickBut :
    <span class="kw">return</span> mClickBut(cl,obj,(<span class="kw">struct</span> MUIMP_MUIClassTutorial_ClickBut *)msg);
  }

  <span class="kw">return</span>(DoSuperMethodA(cl,obj,msg));
}</code></pre>
<p>Until now we have only declared a new method for our private class, without any connection to the MUI notification system. To do so, first of all we need to invoke the already mentioned MUIM_Notify method, that in our previous example of the callbacks worked like this:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(button, MUIM_Notify,
                  MUIA_Pressed, FALSE,
                  MUIV_Notify_Self,
                  <span class="dv">4</span>,
                  MUIM_CallHook,
                  &amp;buttonHook,
                  button,
                  string);

<span class="kw">while</span> in <span class="kw">case</span> of notification using public method we will have:

DoMethod(data-&gt;button, MUIM_Notify,
                   MUIA_Pressed, FALSE,
                   obj,
                   <span class="dv">1</span>,
                   MUIM_MUIClassTutorial_ClickBut);</code></pre>
<p>In other words we are using DoMethod() to do the following: &quot;everytime data-&gt;button object is selected, invoke the MUIM_MUIClassTutorial_ClickBut method on istance obj of our private class&quot;. This is the resulting code:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*****************************************************************************/</span>
<span class="co">// file MUIClass.h                             </span>
<span class="co">/*****************************************************************************/</span>

<span class="ot">#ifndef __MYMUICLASS__</span>
  <span class="ot">#define __MYMUICLASS__</span>

  <span class="ot">#define MUI_CLASS_TUTORIAL (TAG_USER+20)</span>

  <span class="ot">#define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1</span>
  <span class="ot">#define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2</span>
  <span class="ot">#define MUIA_MUIClassTutorial_App MUI_CLASS_TUTORIAL + 3</span>

  <span class="kw">struct</span> MUIMP_MUIClassTutorial_ClickBut
  {
    STACKED ULONG MethodID;

  };


  <span class="ot">#define MUIM_MUIClassTutorial_ClickBut MUI_CLASS_TUTORIAL + 20</span>

  <span class="kw">struct</span> MUI_CustomClass  *initMUIClass();
<span class="ot">#endif</span>
<span class="co">/*****************************************************************************/</span>

<span class="co">/*****************************************************************************/</span>
<span class="co">//file MUIClass.c</span>
<span class="co">/*****************************************************************************/</span>
<span class="kw">struct</span> MyData
{
  Object *button, *str;
  STRPTR labelButton, labelStr;
};


<span class="co">///OM_NEW</span>
<span class="dt">static</span> IPTR mNew(<span class="kw">struct</span> IClass *cl,Object *obj,<span class="kw">struct</span> opSet *msg)
{

  STRPTR labelStr, labelButton;
  Object *str, *button;
  <span class="kw">struct</span> TagItem *tags =((<span class="kw">struct</span> opSet *)msg)-&gt;ops_AttrList;
    
  labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)<span class="st">&quot; &quot;</span>,tags);

  labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)<span class="st">&quot; &quot;</span>,tags);
      
  str = MUI_NewObject(MUIC_String,
                      MUIA_Frame, MUIV_Frame_String, 
                      MUIA_String_Contents,(IPTR) labelStr,
                      TAG_DONE);
    
  button= (Object *) MUI_MakeObject(MUIO_Button,(IPTR) labelButton, TAG_DONE);
                    
  obj = (Object *) DoSuperNew(cl, 
            obj,
            MUIA_Group_Child, str,
            MUIA_Group_Child, button,
            TAG_MORE, msg-&gt;ops_AttrList);

  <span class="kw">if</span> (obj==NULL)
    <span class="kw">return</span> <span class="dv">0</span>;
    
  {
    <span class="kw">struct</span> MyData *data;
    data = (<span class="kw">struct</span> MyData *) INST_DATA(cl,obj);

    data-&gt;str = str;
    data-&gt;button = button;
    data-&gt;labelStr = labelStr;
    data-&gt;labelButton = labelButton;

    DoMethod(data-&gt;button, MUIM_Notify,
                           MUIA_Pressed, FALSE,
                           obj,
                           <span class="dv">1</span>,
                           MUIM_MUIClassTutorial_ClickBut);
  }


  <span class="kw">return</span> (IPTR)obj;
}
<span class="co">///</span>

<span class="co">/// MUIM_MUIClassTutorial_ClickBut</span>
<span class="dt">static</span> IPTR mClickBut(<span class="kw">struct</span> IClass *cl,Object *obj, <span class="kw">struct</span> MUIMP_MUIClassTutorial_ClickBut *msg)
{

  <span class="kw">struct</span> MyData *data;
  Object *bt_1, *str;

  data = (<span class="kw">struct</span> MyData *) INST_DATA(cl,obj);
  bt_1=(Object *) data-&gt;button;
  str=(Object *)  data-&gt;str;

 

  SetAttrs(str,  MUIA_String_Contents,(IPTR) <span class="st">&quot;Button clicked&quot;</span>, TAG_DONE);
  SetAttrs(bt_1, MUIA_Text_Contents,(IPTR) <span class="st">&quot;Clicked!&quot;</span>, TAG_DONE);
  SetAttrs(bt_1, MUIA_Disabled,TRUE, TAG_DONE);
 
  <span class="kw">return</span> (IPTR) obj;
}
<span class="co">///</span>

<span class="co">///MyDispatcher</span>
DISPATCHER(MyDispatcher)
{
  <span class="kw">switch</span> (msg-&gt;MethodID)
  {
    <span class="kw">case</span> OM_NEW :
        <span class="kw">return</span> mNew(cl,obj,(<span class="kw">struct</span> opSet *)msg);
    <span class="kw">case</span> MUIM_MUIClassTutorial_ClickBut :
        <span class="kw">return</span> mClickBut(cl,obj,(<span class="kw">struct</span> MUIMP_MUIClassTutorial_ClickBut *)msg);
  }

  <span class="kw">return</span>(DoSuperMethodA(cl,obj,msg));
}
<span class="co">///</span>

<span class="co">///initMUIClass()</span>
<span class="kw">struct</span> MUI_CustomClass  *initMUIClass()
{
  <span class="kw">return</span> (<span class="kw">struct</span> MUI_CustomClass *) MUI_CreateCustomClass(NULL, MUIC_Group, NULL, 
        <span class="kw">sizeof</span>(<span class="kw">struct</span> MyData), ENTRY(MyDispatcher));

}
<span class="co">///</span>
<span class="co">/*****************************************************************************/</span></code></pre>
<h3 id="mui-notification-through-notifiable-attributes">4.8.1 MUI: notification through notifiable attributes</h3>
<p>We have already mentioned the case where changing the value of an attribute leads to the execution of an action. In our case the attribute was already provided by the MUI class that we were using, more precisely we are referring to the MUIA_Pressed attribute. We could think that changing a value of any attribute of a MUI class triggers our function according to the above mentioned rules, but this is not completely true. Actually only some attributes of each of MUI classes can trigger an action everytime their value changes. First of all let's explicit a concept we have only silently expressed: an attribute is defined &quot;notifiable&quot; when it allows plugging an action on any change of its value. As we said, not every attribute provided by a MUI class is notifiable; moreover attributes of our private classes are not notifiable unless we explicitely make them so. There are specific rules to respect in case we want to make an attribute of our private class notifiable, so to be able to plug it to an action triggered by some other class. To better understand, now it's time to list the object packet (the message) of the OM_GET method:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> opGet
{
  STACKED ULONG  MethodID;      <span class="co">/*OM_GET                             */</span>
  STACKED Tag    opg_AttrID;    <span class="co">/*attribute to be read               */</span>
  STACKED IPTR   *opg_Storage;  <span class="co">/*memory area that contains          */</span>
                                <span class="co">/*the attribute value requested      */</span> 
};</code></pre>
<p>The message handling by the Get method of a class is quite easy: the function designated to overload the OM_GET method will simply check if inside opg_AttrID there is the ID of an attribute belonging to its own class. If the answer is positive, the function will use the opg_Storage memory area, putting the value of the requested attribute; finally the function will return TRUE. This latest value, according to BOOPSI rules, indicates that the operation succeded. If, on the other hand, opg_AttrID does not contain any known attribute, the function will push the message upwards to the superclass, as usual.</p>
<p>We have now explained the main steps concerning the OM_GET method because the first and most important rule of MUI to obtain an notifiable attribute is to make it readable &quot;outside&quot;, or - using a better word - our attribute must be &quot;gettable&quot;.</p>
<p>Obviously we need our attribute to trigger a notification only if the new value is not equal to the current value of the attribute. For example, if our attribute's value is TRUE, we don't want to be informed that it is being &quot;changed&quot; again to TRUE. In order to do so, there's only to overwrite the ID in the ti_Tag field of our attribute's OM_SET message with TAG_IGNORE. This way we will also avoid weird situations.</p>
<p>Now we have all the theoretical elements to make our attribute notifiable, so there's only to show a practical example.</p>
<p>Let's say the we have three classes, binded by a hierarchical link: Class1 and Class2 are known to Class3 but they're in direct contact. This could be a representation of these relationship:</p>
<pre><code>Classe1---&gt;Classe3&lt;---Classe2</code></pre>
<p>Each of these classes has a private data area which is only known to each other, respecting the concept of information hiding. Let's also suppose that each of these classes has its own set of attributed and public methods. Now we want that when the value of the MUIA_Class1_Attr1 attribute changes to TRUE, Class2 executes its own MUIM_Class2_Method2 method. First of all, concerning Class1 we will have a situation like the following:</p>
<pre class="sourceCode c"><code class="sourceCode c">*******************************************************************************
<span class="kw">struct</span> dataArea1
{
  LONG attr1;
  ....
};

*******************************************************************************
....
<span class="co">//method OM_GET</span>
IPTR GetClass1(<span class="kw">struct</span> IClass *cl,Object *obj,<span class="kw">struct</span> opGet *msg)
{
  <span class="kw">struct</span> dataArea1 *data = INST_DATA(cl, obj);

  <span class="kw">switch</span> (msg-&gt;opg_AttrID)
  {
    <span class="kw">case</span> MUIA_Class1_Attr1:
      *msg-&gt;opg_Storage = (LONG) data-&gt;attr1;
      <span class="kw">return</span> TRUE;

    ...
  }

  <span class="kw">return</span> DoSuperMethodA(cl,obj,(Msg)msg);
}                                         
*******************************************************************************

<span class="co">//method OM_SET</span>
IPTR SetClass1(<span class="kw">struct</span> IClass *cl,Object *obj,<span class="kw">struct</span> opSet *msg)
{
  <span class="kw">struct</span> dataArea1  *data = INST_DATA(cl,obj);

  {<span class="co">/*code block to read the tags list*/</span>
    <span class="kw">struct</span> TagItem *tags, *tag;
    tags=((<span class="kw">struct</span> opSet *)msg)-&gt;ops_AttrList;

    <span class="kw">while</span> (tag=NextTagItem((TAGITEM)&amp;tags))
    {
      <span class="kw">switch</span> (tag-&gt;ti_Tag)
      {
        <span class="kw">case</span> MUIA_Class1_Attr1:
         <span class="kw">if</span> (data-&gt;attr1==tag-&gt;ti_Data) tag-&gt;ti_Tag = TAG_IGNORE;
        <span class="kw">else</span>                                                                        
          data-&gt;attr1 = (LONG) tag-&gt;ti_Data;
        <span class="kw">break</span>;

        ...
      }
    }
  }

  <span class="kw">return</span> DoSuperMethodA(cl,obj,(Msg)msg);
}
....
 
*******************************************************************************</code></pre>
<p>In this way the attribute MUIA_Class1_Attr1 notifies its own status change from outside Class1. In order to trigger MUIM_Class2_Method2 let's suppose we have instanced two objects inside Class3, one from Class1 and the other from Class2:</p>
<pre class="sourceCode c"><code class="sourceCode c">....

Object *obj1, *obj2;

obj1 = NewObject(Class1-&gt;mcc_Class,  NULL, TAG_DONE);
obj2 = NewObject(Class2-&gt;mcc_Class,  NULL, TAG_DONE);

....</code></pre>
<p>Now we only have to link the notification as usual:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(obj1,  MUIM_Notify,
        MUIA_Class1_Attr1, TRUE,
        obj2,
        <span class="dv">1</span>,
        MUIM_Class2_Method2);</code></pre>
<h3 id="mui-notification-chains">4.8.2 MUI: notification chains</h3>
<p>In paragraph 4.8.1 we have learned how to make notifiable an attribute of our class. Often we have a hierarchy of classes where a class on top of it should be notified of a value changed in an attribute of one of its subclasses. Let's see the following example of class hierarchy:</p>
<pre><code>Class1--&gt;Class2--&gt;Class3</code></pre>
<p>Class3 does not know about Class1 since our system respects the incapsulation and information hiding paradigm. Class2 has an attribute (MUIA_Class2_Attr2) which value can be that of a Class1 attribute (MUIA_Class1_Attr1). Also, Class3 has an attribute (MUIA_Class3_Attr3) which value can be taken from a Class2 attribute (MUIA_Class2_Attr2).</p>
<p>In other words we have a class relationship in which changing value to attribute MUIA_Class1_Attr1 triggers a notification in Class2 attribute MUIA_Class2_Attr2; same thing happens for Class3 attribute MUIA_Class3_Attr3. We observe that Class3 has an instance of Class2 and Class2 has an instance of Class1:</p>
<pre class="sourceCode c"><code class="sourceCode c">MUIA_Class1_Attr1 = MUIA_Class2_Attr2 = MUIA_Class3_Attr3</code></pre>
<p>In order to make all this work, the first thing to do is describe the OM_GET and OM_SET methods for each one of these three classes, just like in paragraph 4.8.1. We will have a &quot;instance1&quot; object that will be our instance of Class1 inside Class2; then, somewhere in Class2 (usually inside the OM_NEW method) we need the notification:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(instance1, MUIM_Notify,
           MUIA_Class1_Attr1, MUIV_EveryTime,
           obj,
           <span class="dv">3</span>,
           MUIM_Set,
           MUIA_Class2_Attr2,
           MUIV_TriggerValue);</code></pre>
<p>MUIV_EveryTime is a special MUI value that instucts the system to catch any valid change (an actual change of value, that is) in MUIA_Class1_Attr1 attribute value. MUIM_Set is nothing but our OM_SET method a bit modified: as we know, OM_SET requires a taglist, but building such a parameter would be a bit tedious. This is why MUI offers the MUIM_Set method; it allows to pass parameters without the need of a taglist, just like in the previous example. MUIV_TriggerValue is another special value that tells the system to pass on to a method, in our case MUIM_Set, any value that is being notified through MUIV_EveryTime. Basically MUI replaces MUIV_TriggerValue with the value that triggered the notification.</p>
<p>Same behaviour will be observed for MUIA_Class2_Attr2 and MUIA_Class3_Attr3 while building the following notification:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(instance2, MUIM_Notify,
           MUIA_Class2_Attr2, MUIV_EveryTime,
           obj,
           <span class="dv">3</span>,
           MUIM_Set,
           MUIA_Class3_Attr3,
           MUIV_TriggerValue);</code></pre>
<p>Now, everytime MUIA_Class1_Attr1 will change value, this event will trigger a reaction also on MUIA_Class2_Attr2 and MUIA_Class3_Attr3 attributes.</p>
<p>As the last thing, we can now implement in a different way the example shown in paragraph 4.5.1, without using hooks or new methods of the class to be defined. We will only need three notifications: in the example from paragraph 4.5.1 we had a button, a string and three attributes that changed when MUIA_Pressed value changed. We can accomplish all that with the following code:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(button, MUIM_Notify,
          MUIA_Pressed, FALSE,
          string,
          <span class="dv">3</span>,
          MUIM_Set,
          MUIA_String_Contents,
          <span class="st">&quot;Clicked button&quot;</span>);  

DoMethod(button, MUIM_Notify,
          MUIA_Pressed, FALSE,
          button,
          <span class="dv">3</span>,
          MUIM_Set,
          MUIA_Text_Contents,
          <span class="st">&quot;Clicked!&quot;</span>);

DoMethod(button, MUIM_Notify,
          MUIA_Pressed, FALSE,
          button,
          <span class="dv">3</span>,
          MUIM_Set,
          MUIA_Disabled,
          TRUE);</code></pre>
<h3 id="mui-warnings-about-using-notified-attributes">4.8.3 MUI: warnings about using notified attributes</h3>
<p>In paragraph 4.8.2 we have realized a couple of notifications that in some way connected three classes to each other:</p>
<pre><code>Class1--&gt;Class2--&gt;Class3</code></pre>
<p>This connection is one-way only since the attribute notification goes from Class1 to Class3. Sometimes we would like to also notify MUIA_Class1_Attr1 when MUIA_Class3_Attr3 changes. In order to do so we would need to synchronize these value changes, having these notifications go back and forth; however such connections would lead to an endless loop of the MUI notification facility offered by MUI:</p>
<pre><code>  --&gt;Class1--&gt;Class2--&gt;Class3--
  |                            |
  -------------Class2&lt;---------</code></pre>
<p>If we want to overcome this limitation, we should &quot;break&quot; the loop where it makes sense: on the one hand, when the value change of MUIA_Class1_Attr1 reaches Class3 and, on the other, when the value change of MUIA_Class3_Attr3 reaches Class1; after reaching the designated class and setting the destination attribute accordingly, both notifications will stop. To do so, we should provide a piece of code like the following:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(obj, MUIM_Notify,
              MUIA_Class3_Attr3, MUIV_EveryTime,
              instance2,
              <span class="dv">3</span>,
              MUIM_Set,
              MUIA_Class2_Attr2,
              MUIV_TriggerValue);

DoMethod(instance2, MUIM_Notify,
           MUIA_Class2_Attr2, MUIV_EveryTime,
           obj,
           <span class="dv">3</span>,
           MUIM_NoNotifySet,
           MUIA_Class3_Attr3,
           MUIV_TriggerValue);</code></pre>
<p>The first function call to MUIM_Notify it's easy to understand: basically we have linked the value changing of MUIA_Class3_Attr3 to MUIA_Class2_Attr2; we are propagating our notification from Class3 to Class2. Same thing must be done in Class2 in order to propagate the notification to Class1. In the second function call to MUIM_Notify we have used MUIM_NoNotifySet instead of MUIM_Set.</p>
<p>The MUIM_NoNotifySet method executes the same actions of MUIM_Set without notifying MUI about the changes that are being performed to a certain attribute. In other words we have performed the first interruption on our notification loop. Now we have to perform the second interruption, which will be in Class2:</p>
<pre class="sourceCode c"><code class="sourceCode c">DoMethod(obj,   MUIM_Notify,
                MUIA_Class2_Attr2, MUIV_EveryTime,
                instance1,
                <span class="dv">3</span>,
                MUIM_NoNotifySet,
                MUIA_Class1_Attr1,
                MUIV_TriggerValue);</code></pre>
<h4 id="warnings-about-chained-notifications-in-zune">4.8.3.1 Warnings about chained notifications in Zune</h4>
<p>MUI recognizes and manages accordingly the case where there are chained notifications. In other words, in a situation like the following:</p>
<pre><code> --&gt;MUIA_Class1_Attr1 --&gt; MUIA_Class2_Attr2 --&gt; MUIA_Class3_Attr3--&gt; MUIA_Class4_Attr4--&gt;
 |                                                                                      |
(#)                                                                                    (#)
 |                                                                                      |
 &lt;--MUIA_Class1_Attr1 &lt;-- MUIA_Class2_Attr2 &lt;-- MUIA_Class3_Attr3&lt;-- MUIA_Class4_Attr4&lt;--</code></pre>
<p>where (#) represents the loop interruption provided by MUIM_NoNotify_Set, MUI automatically breaks the &quot;subloops&quot; that could be generated in between the notifications. To better understand, in the above situation the following subloop could show up:</p>
<pre><code> --&gt;MUIA_Class2_Attr2 --&gt; MUIA_Class3_Attr--&gt;
 |                                          |
 |                                          |
 &lt;--MUIA_Class2_Attr2 --&gt; MUIA_Class3_Attr&lt;-- </code></pre>
<p>In this case MUI 3.8+ breaks the subloop, preventing any possible unwanted interaction between notifications, without breaking the notification chain.</p>
<p>All this does not happen with Zune. In the latest versions Zune recognizes loops, but the countermeasures are not as quick as in MUI. As a workaround of this &quot;bug&quot;, in Zune there is a further action to be performed, besides the two MUIM_NoNotifySet at the end of the loops; the developer has also to decouple the attributes in use. In other words, when possible, the same attributes should have different labels. In our example:</p>
<pre><code> --&gt;MUIA_Class1_Attr1 --&gt; MUIA_Class2_Attr2_X --&gt; MUIA_Class3_Attr3_X --&gt; MUIA_Class4_Attr4--&gt;
 |                                                                                           |
(#)                                                                                         (#)
 |                                                                                           |
 &lt;--MUIA_Class1_Attr1 &lt;-- MUIA_Class2_Attr2_Y &lt;-- MUIA_Class3_Attr3_Y &lt;-- MUIA_Class4_Attr4&lt;--</code></pre>
<p>In this example MUIA_Class2_Attr2_X equals MUIA_Class2_Attr2_Y and MUIA_Class3_Attr3_X equals MUIA_Class3_Attr3_Y. What is actually needed is to declare new labels that in the OM_SET and OM_GET methods will be used to execute the same actions as of the original labels. Of course this approach works fine in MUI too, therefore it should be the preferred method in case of portable applications.</p>
<h2 id="mui-synchronizations-muim_application_pushmethod-and-muim_application_killpushmethod">4.9 MUI: synchronizations, MUIM_Application_PushMethod and MUIM_Application_KillPushMethod</h2>
<p>MUI provides that all notifications triggered while iterating the main event control loop (see paragraph 4.5.2) will be executed inside the current iteration. What is not guaranteed, however, is the order these notifications will be executed. Let's see two examples of chain notifications:</p>
<pre><code>Class1_AttrA --&gt; Class2_AttrA --&gt; Class3_AttrA  --&gt; Class4_AttrA</code></pre>
<p>and</p>
<pre><code>Class1_AttrB --&gt; Class2_AttrB --&gt; Class3_AttrB  --&gt; Class4_AttrB</code></pre>
<p>MUI will guarantee that Class4_AttrA and Class4_AttrB will eventually be notified of the value change of (respectively) Class1_AttrA and Class1_AttrB during an iteration of the event control loop, but it doesn't guarantee which one will be notified first or last. In other words, the two following instructions:</p>
<pre class="sourceCode c"><code class="sourceCode c">SetAttrs(objFromClass1, Class1_AttrA, value1, TAG_DONE);
SetAttrs(objFromClass1, Class1_AttrB, value2, TAG_DONE);</code></pre>
<p>can be equally given in opposite order:</p>
<pre class="sourceCode c"><code class="sourceCode c">SetAttrs(objFromClass1, Class1_AttrB, value2, TAG_DONE);
SetAttrs(objFromClass1, Class1_AttrA, value1, TAG_DONE);</code></pre>
<p>and it will be exactly the same. The order MUI will set the attributes Class4_AttrA and Class4_AttrB is not predictable.</p>
<p>This is especially visible in case of long chained notifications with many methods involved. Although in our code notifications are triggered in a logical order, it is possible that they will not be executed according to that order. It is therefore very important to avoid assumptions about the order execution of our algorithms when they involve notification chains.</p>
<p>It is however possible to maintain a certain degree of order execution also in case of long notification chains using a special method, which main use is not connected to notifications: MUIM_Application_PushMethod.</p>
<p>MUIM_Application_PushMethod takes as parameters a method along with its arguments and incapsulate them in a private data area of the MUIC_Application object that had invoked said method. The encapsulated method is therefore maintained until the following iteration of the event control loop, actually slowing down its execution.</p>
<p>In other terms, suppose considering the nth iteration of the event control loop, we can write the following code:</p>
<pre class="sourceCode c"><code class="sourceCode c">LONG pushIDFoo = <span class="dv">0</span>, pushIDBar= <span class="dv">0</span>;

pushIDFoo = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objFooClass1, 
                        <span class="dv">3</span>, 
                        MUIM_Set, 
                        Class1_AttrA, 
                        value1);

pushIDBar = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objBarClass1,
                        <span class="dv">3</span>, 
                        MUIM_Set, 
                        Class1_AttrB, 
                        value2);</code></pre>
<p>this way the attribute Class4_AttrA will be set during the nth+1 iteration of the control loop, and the attribute Class4_AttrB will be set during the the nth+2 iteration of the control loop.</p>
<p>Starting with MUI 3.9, MUIM_Application_PushMethod returns a value that identifies the method put into the memory area. This value is useful in case we would like to manually remove that very method that is being &quot;pushed&quot;.</p>
<p>It's important to note that the private memory area we mentioned before can be easily filled up if MUIM_Application_PushMethod is invoked too many times before the following iteration of the event control loop occurs.</p>
<p>When this buffer is all used, unpredictable situations can arise, a MUI crash in the worst case. For example when invoked inside our subclass MUIM_Draw method, or when there are many OM_SET calls to set an attribute.</p>
<p>In other terms, these dangerous situations show up when the attribute is set to a temporary value many times before being set to its final value (imagine the various interim values indicating the position of a scroller). In order to avoid all this, and in this case only, it is possible to use a non-documented MUI method (supported by Zune too) which definition is as follows:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define MUIM_Application_KillPushMethod 0x80429954</span></code></pre>
<p>By invoking this method we will manually remove from the buffer the previous methods archived for a certain object. Starting from MUI 3.9, as mentioned before, it is possible to perform a specific method removal, using the return value of the method MUIM_Application_PushMethod. In case of previous versions of MUI or Zune, this value will be ignored and the last method pushed to the buffer will be removed (the MUIM_Application_PushMethod method returns TRUE on MUI 3.8 and Zune if the method linked to it has been added to the private buffer). Our previous code will turn into the following:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (pushIDFoo)
{
    DoMethod(objApp, MUIM_Application_KillPushMethod,
                objFooClass1,
                pushIDFoo);

    pushIDFoo = <span class="dv">0</span>;
}

pushIDFoo = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objFooClass1,
                        <span class="dv">3</span>, 
                        MUIM_Set, 
                        Class1_AttrA,
                        value1);

<span class="kw">if</span> (pushIDBar)
{
    DoMethod(objApp, MUIM_Application_KillPushMethod, 
              objBarClass1, 
             pushIDBar);

    pushIDBar=<span class="dv">0</span>;
}

pushIDBar = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objBarClass1, 
                        <span class="dv">3</span>, 
                        MUIM_Set, 
                        Class1_AttrB,
                        value2);</code></pre>
<p>Of course this piece of code also works in case of MUI 3.9 and earlier versions, Zune included, since the &quot;pushIDxxxx&quot; of the message definition of the earlier versions of MUIM_Application_KillPushMethod have that flag set to zero.</p>
<h2 id="mui-a-bit-more-about-hooks-private-methods-and-notifications">4.10 MUI: a bit more about hooks (private methods and notifications)</h2>
<p>Until now we have learned how to implement public attributes and methods for our classes, without expliticing the concept of private attributes and methods. It is clear that private attributes and methods are nothing but variables and functions used inside a class itself. We know how the BOOPSI standard identifies public attributes and methods through symbols we declare; think of our previous examples: MUIM_MUIClassTutorial_ClickBut, MUIA_Class1_Attr1 and so on.</p>
<p>We have also shown the so called notifiable attributes, that are simply public attributes implemented following specific rules that allow alerting MUI of their value change. Actually we have already mentioned how to manage private attributes and methods: using hoooks (paragraph 4.5.1). Using a hook allows us declaring a function just like a public method, without having this new function to be known outside the class itself, according to BOOPSI ruling. In other words, if used correctly, hooks can be a powerful tool to improve the encapsulation of our class, as long as the hook is not reachable from outside the class that is implementing and using it.</p>
<p>In our first example, where we had a button and a string linked through a notification, we were inside the class that declared these objects, therefore using a hook to implement the notification would have been the best solution. On the other hand, when we have to connect two objects belonging to two different classes, our choice would be to implement the notification through a public method or a notifiable attribute.</p>
<p>Now let's recap briefly, we have learned that a MUI class can have:</p>
<ul>
<li><p>Private attribute: these are variables declared inside the private data area of our class and are not associated with any symbol.</p></li>
<li><p>Public attribute: these are variables (usually) declared inside the data area of the class and they are associated in OM_NEW/OM_SET/OM_GET to symbols (e.g. MUIA_Class1_Attr1).</p></li>
<li><p>Notifiable attributes: these are public attributes which value change is catched and/or modified by MUI through methods such as MUIM_Notify and MUIM_Set.</p></li>
<li><p>Private methods: these are utility functions, defined and used inside a class, but not associated to any symbol;</p></li>
<li><p>Private methods linkable to notifications: these are functions associated to hooks, listening to the value change of notifiable attributes through methods such as MUIM_Notify and MUIM_CallHook;</p></li>
<li><p>Public methods: these are functions declared and defined that are associated in the class dispatcher to symbols (e.g. MUIM_MUIClassTutorial_ClickBut) and linked to notifiable attributes through MUIM_Notify;</p></li>
</ul>
<h2 id="mui-macro-shortcuts">4.11 MUI macro shortcuts</h2>
<p>On many occasions, while being compliant to the OOP paradigm, there are objectively problems, let's think of the already mentioned MUIM_Application_PushMethod. This method belongs to the MUIC_Application class, but in many cases it would be also useful using it inside objects of our subclasses from an instance of MUIC_Application, even though - in theory - these objects should not be allowed to directly communicate with the instance.</p>
<p>When such an situation (and many other) occurs, instead of passing important addresses through subclasses that are not supposed to know that kind of external detail, it is possible to use the so called MUI shortcuts. It is not advisable to always use these shortcuts, you have to know what you're doing; also - from a theoretical standpoint - they break the OOP paradigm. In brief, pay attention to avoid creating spaghetti-code.</p>
<p>Let's make another example: suppose we have a generic &quot;obj&quot; object. Some of the most used MUI shortcuts are:</p>
<pre class="sourceCode c"><code class="sourceCode c">_app(obj) = returns the MUIC_Application instance containing our object;
_win(obj) = returns the MUIC_Window instance containing our object;</code></pre>
<p>Namely these two shortcuts are usable only after the MUIM_Setup has been invoked from our MUI subclass and before MUIM_Cleanup has been invoked. So, for example, if these shortcuts are being used inside a OM_NEW or OM_DISPOSE method the application would crash.</p>
<p>Although these MUI shortcuts has been provided to create low level graphic classes (just have a look at the sources of some MUI classes like TextEditor MCC and similar classes), by using them our code is able to invoke methods outside of our subclass without getting us mad trying.</p>
<p>It is suggested to read the mui.h header to find all the available MUI shortcuts and learn when they can be used.</p>
<h1 id="the-communication-between-tasks-on-amiga">The Communication between tasks on Amiga</h1>
<p><em>&quot;Message passing is faster on ami cause it just passes around pointers to structs[...]&quot;</em> Tom &quot;Phantom Lord&quot; Kennedy, comp.sys.amiga.advocacy, May 5, 1994</p>
<p><em>&quot;copy-on-write message passing would be really great on the Amiga, since you could get memory protection&quot;</em> Gavriel State, comp.sys.amiga.advocacy, Feb 26, 1992</p>
<p><em>&quot;AmigaOS definitely cannot, at least not without breaking existing software. That's because an arbitrarily large chunk of memory (or even many of them, if you pass a list) may be &quot;attached&quot; to the message structure and would have to be copied to the receiver's address space. But the OS doesn't know how much data actually belongs to your message. Most programmers don't care much about the mn_Length field, and even if they did it wouldn't work for lists.&quot;</em> Matthias Bethke, comp.sys.amiga.programmer, Dec 18, 1996</p>
<h2 id="different-kinds-of-interaction">5.1 Different kinds of interaction</h2>
<p>So far we just took care of writing programs that identify themselves inside the system as a little universe, with its own rules and its own borders. The only external interation has been the one through graphic feedback, in our example we cited several times the button pressing, that is recognized from our program and is handled in a certain way. The feedback was finally shown to the user. We also treated in other terms the problem of the interaction between user and program; instead now we are going to look at the interaction between the program, the system and other programs.</p>
<h2 id="an-introduction-to-signals">5.2 An introduction to signals</h2>
<p>The Amiga system warn a task about a determinate event through signals. A signal is represented by one or more bits inside a 32-bit field, and this field is assigned to each task. Each task has an overall of 32 signals, with 16 of them reserved to the OS. We already met and interacted with some of the reserved signals, in particular in the paragraph 4.5.2 we made our application able to interact in case 4 reserved bits of our task were changed:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">while</span> (DoMethod(app,MUIM_Application_NewInput,&amp;sigs) != MUIV_Application_ReturnID_Quit)
{
  <span class="kw">if</span> (sigs)
  {
    sigs = Wait(sigs | SIGBREAKF_CTRL_C);
    <span class="kw">if</span> (sigs &amp; SIGBREAKF_CTRL_C) <span class="kw">break</span>;
  }
}</code></pre>
<p>Those 4 bits are shown with the symbol SIGBREAKF_CTRL_C. The generic change of our task mask is instead reported inside the sigs integer, using the MUIM_Application_NewInput method. Through the Wait() function, instead we tell the system to send our task in Sleep state and to wake it up only in case of the mask SIGBREAKF_CTRL_C or any other mask inside sigs are detected. So far, the described cycle workflow should be quite clear: until MUIM_Application_NewInput is returning a different value than MUIV_Application_ReturnID_Quit (the window close gadget associated value) will check the signal mask put in sigs. If sigs value is different from zero then the Wait() function is invoked so that the task is sent in Sleep and will be awaken only if the same mask inside sigs is detected or in case the one shown by SIGBREAKF_CTRL_C is detected. In general, in case we would like to send our task to Sleep and wake it up only if the signal 3 is received, we should use something like:</p>
<pre class="sourceCode c"><code class="sourceCode c">Wait(1L&lt;&lt;<span class="dv">3</span>);</code></pre>
<p>Through the left shift, the value 00000000000000000000000000000001 becomes 00000000000000000000000000001000,that is the &quot;3&quot; signal. Each task (struct task) keep inside several signal masks; is important to note the mask used to contain the allocated task signals (tc_SigAlloc) and the mask used to keep the signals that the task might wait to receive (tc_SigWait). Therefore a task might allocate signals, giving them a meaning of its own, and eventually wait for their coming. That is the reason which is said that a task signals concerns the task itself.</p>
<h2 id="ports-and-messages">5.3 Ports and Messages</h2>
<p>Lets suppose we have two running tasks, A and B. The A task needs to communicate some informations to task B; we need a communication standard to make data from A have a meaning for B and the reverse. Most operating systems solves this problem giving to the programmer an indirect communication through messages and ports (IPC). In indirect communication, the task A &quot;writes&quot; a message with the required data for B and sends it through a communication port. We can compare the communication port to a Mailbox of someone, the task B in this case. Once the message reaches the destination port, it can be taken by B and used for its own internal processes. In some cases the target task is waiting for a message in a specific port, in some other cases the recipient is waiting after the message has been sent to a port; the latter is called synchronous communication. The reverse, meaning, sending and receiving messages does not include waiting, is instead called &quot;Asynchronous communication&quot;. It can also be possible that a notification of the message arrival can be requested, and sometimes might be needed to also notify the completion of the actions made through the data contained in the received message. All Amiga OSes support the described cases through a series of functions offered by Exec.</p>
<p>5.3.1. Messages on Amiga OSes</p>
<p>A message, in Amiga OSes, is composed by a header and a body. The header the message is handled by the system, while the body of the message can have any kind of format and shape. In other terms, an Amiga OS message is a simple structure composed with a mandatory field and other field made by programmer choice. In this example, if we need to compose a message containing an integer we can write:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MyMessage{
  <span class="kw">struct</span> Message msg;   
  <span class="dt">int</span> myInteger;
};</code></pre>
<p>In this case the message body is represented from our integer, while the struct Message is system header and it is still constant. The last one is composed like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> Message {
  <span class="kw">struct</span> Node  mn_Node;
  <span class="kw">struct</span> MsgPort  *mn_ReplyPort;
  UWORD mn_Length;
};</code></pre>
<p>The first structure field is used to hook the message to a port. The second field, sometimes not mandatory, is filled with a pointer to an answering port in case there is the need to answer with the same datas (or different datas) to the recipient task. The third and last field, instead, shows the message length.</p>
<p>In Amiga OS's messages are passed between tasks through addresses, meaning that when the task A creates and sends a message to task B, this one will receive a pointer to the message, not a copy of it. In a similar situation, therefore, the message exchanging is nothing other than a way for a task to have granted access to a chunk of allocated memory and, apparently, to another task. This implementation is obviously accidental to the protected memory implementation (see par. 2.6.1), besides that this IPC implementation has been kept in the newer Amiga OSs in order to keep some compatibility with the older Amiga OS 3.x apps. Amiga OS 3.x use often the IPC system and, therefore, implementing a different system than IPC on newer Amiga OSes means that older Amiga OS 3.x applications cannot run in those systems, unless through complicated emualtion systems.</p>
<h3 id="creation-search-and-removal-of-port-in-amiga-oss">5.3.2 Creation, search and removal of Port in Amiga OS's</h3>
<p>In the last paragraph, one of the fields in the Message structure was represented by a pointer to MsgPort structure, it is the message port representation in the Amiga Os's:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MsgPort
{
    <span class="kw">struct</span> Node mp_Node;
    UBYTE       mp_Flags;
    UBYTE       mp_SigBit;  
    APTR        mp_SigTask; 
    <span class="kw">struct</span> List mp_MsgList; 
};</code></pre>
<p>The first field, mp_Node, is the header and through it the port is added to the system lists handled by Exec; the last field, mp_MsgList contains a pointer to the messages list queued inside the port. The mp_SigTask field anchors the pointer to the task which the port belongs, and this one represents the destination task, which will need to be warned of the incoming message through the signal mask mp_SigBit. Anyway, it is possible to modify the port behavior at the moment of receiving a message; to obtain this, the field mp_Flags is available; in a generic case it assumes the special value PA_SIGNAL; instead, in case the message arrival has to come unnotified, the field will be set to PA_IGNORE. Usually, the message port fields are not allocated by hand, beside particular cases. The generic case uses the function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MsgPort *CreateMsgPort( VOID ); </code></pre>
<p>which takes care to allocate the port and its fields automatically setting, in the example, the field mp_Flags to the value PA_SIGNAL and the field mp_SigTask to the corresponding task.</p>
<p>A port can be private or public. If our needs are focusing us on the second option, we should then act by hand on two mp_Node subfields belonging to the allocated port with CreateMsgPort(). In detail, we will be forced to assign a symbolic name and a priority to our port so that it can be added and recognized unequivocally from the system. For example, if we would like to allocate the public port Pippo, we need to write:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MsgPort *fooPort = CreateMsgPort();
 
fooPort-&gt;mp_Node.ln_Name = <span class="st">&quot;Foo&quot;</span>;
fooPort-&gt;mp_Node.ln_Pri = <span class="dv">0</span>;

AddPort(fooPort); </code></pre>
<p>Doing so we assigned the name &quot;Foo&quot; to the port and set its priority to zero. To add this port to the list of the ports handled by Exec we then use the function call:</p>
<pre class="sourceCode c"><code class="sourceCode c">VOID AddPort( <span class="kw">struct</span> MsgPort *port );</code></pre>
<p>In case of a public port we could look for this one using its symbolic name that identifies it in the Exec lists. This information is used as a parameter for the function:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MsgPort *FindPort( CONST_STRPTR name );</code></pre>
<p>Besides that, we need to highlight the fact that a task doesn't have complete control over public ports; in fact these might be changed or removed without notice; therefore the use of a public port has to be put in a privileged condition or, in other words, the port use code has to be put in a code block delimited by the system calls Forbid() and Permit(). In particular, the validity of a public port cannot in any way be guaranteed after a Permit() call and, therefore, extreme caution is needed.</p>
<p>Once we used our public port, we need to remove it from the Exec's Public ports list. To do this we use the function:</p>
<pre class="sourceCode c"><code class="sourceCode c">VOID RemPort( <span class="kw">struct</span> MsgPort *port );</code></pre>
<p>Last, to remove the port from the memory, either a public or private port, we will use the function:</p>
<pre class="sourceCode c"><code class="sourceCode c">VOID DeleteMsgPort( <span class="kw">struct</span> MsgPort *port );</code></pre>
<h3 id="amiga-oss-message-handling">5.3.3 - Amiga OS's Message Handling</h3>
<p>The Message Handling on Amiga OS's can happen synchronously or Asynchronously, using in what is supposed the best way, the following functions:</p>
<pre class="sourceCode c"><code class="sourceCode c">VOID             PutMsg( <span class="kw">struct</span> MsgPort *port, <span class="kw">struct</span> Message *message );
<span class="kw">struct</span> Message * WaitPort( <span class="kw">struct</span> MsgPort *port );
<span class="kw">struct</span> Message * GetMsg( <span class="kw">struct</span> MsgPort *port );
VOID             ReplyMsg( <span class="kw">struct</span> Message *message );</code></pre>
<p>PutMsg() is used when it is needed to send a message to a port. The message sending might involve the loss of control of the CPU (context switching) from the recipient task, which would give the resource to the receiving task. In case that from the recipient task an answer is requested, in the field mn_ReplyPort, situated inside our message header, will be inserted a pointer to an eventual port, which will be used as &quot;answer box&quot;. If we need to do so, the mn_ReplyPort field will need to be configured before PutMsg() is called.</p>
<p>WaitPort() allow a task to wait for an incoming message in a specified port. The task will be set on Sleep if no message is coming on the specified port and will switch to execution in case of an incoming message to the port. In this case WaitPort() will return the pointer to the message; by the way this function will not take care of the removal of the message from the port. To do that, we will use the GetMsg() function. GetMsg() let's us obtain the pointer to the first message inside a port with no wait. If the port contains no message, GetMsg will return the NULL value. If messages are present, GetMsg() will remove the first received message from the port, returning its pointer.</p>
<p>ReplyMsg() is used in the moment the ongoing operations of the receiving task is completed. If for example, the receiving task, once obtained the message, executes some operations for which the received message contained the required data, the receiving task will notify the completion of the operations to the recipient task through a call to ReplyMsg(). ReplyMsg() is also used to give back the control to the message (that is nothing other than a memory block) to the recipient task, so that this one can deallocate the resources used by the message. In other words, a synchronization is made between recipient and receiver, using for the purpose the same message processed by the receiver, that will be given back to the recipient task through ReplyMsg(). ReplyMsg() uses the mn_ReplyPort field inside the message header, where the function expects a pointer to a port in which to send back the message.</p>
<h3 id="ipc-synchronous-communication-step-by-step">5.3.4 IPC synchronous communication step-by-step</h3>
<p>Now let's go back to the beginning problem: we have two tasks, A and B that need to communicate to each other. The communication will happen through the exchange of one or more messages. In order to have all this working, every task will have its own port, that will call Port_A and Port_B.</p>
<p>Let's suppose that task B has defined a symbolic name for its Port_B, and made it a public port.</p>
<p>Now, task A wants to send a message to task B and starts then to prepare one, putting the message length in mn_Length and a reference to Port_A in mn_ReplyPort.</p>
<p>Then task A looks for Port_B through its symbolic name using FindPort(). As we already know, a public port can be accessed and modified in any moment from a task; therefore the FindPort() call must be included in a Forbid() / Permit() block.</p>
<p>Now task A can send its message using PutMsg(), which will require as the first argument the pointer to Port_B returned by FindPort() and the pointer to the previously prepared message.</p>
<p>At this point the task might decide to wait until the message reaches the receiver and that it will finish the operations involving the message. In order to achieve this, the function WaitPort() is used, followed by a call to GetMsg(), which will remove the message from the port. The calls to WaitPort() and GetMsg() might be enclosed in a loop, depending on how many messages the two tasks will need to swap; right now we are considering one message exchange only.</p>
<p>So, right now we have a similar situation inside the task A corresponding program, consider the example in the message struct MyMessage:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> MyMessage
{
  <span class="kw">struct</span> Message msg;
  <span class="dt">int</span> myInteger;
};

...

{<span class="co">//communication part</span>
  
  <span class="kw">struct</span> Process *this = (<span class="kw">struct</span> Process *) FindTask(NULL);
  <span class="kw">struct</span> MsgPort *Port_A =(<span class="kw">struct</span> MsgPort *) &amp;this-&gt;pr_MsgPort;
  <span class="kw">struct</span> MyMessage myMsg;

  myMsg.myInteger = <span class="dv">3</span>;
  myMsg.msg.mn_Length = <span class="kw">sizeof</span>(<span class="kw">struct</span> MyMessage);
  myMsg.msg.mn_ReplyPort = Port_A;

  Forbid();
  {<span class="co">// Forbid()/Permit() block</span>

    <span class="kw">struct</span> MsgPort Port_B = FindPort(<span class="st">&quot;Port_B&quot;</span>);

    <span class="kw">if</span> (Port_B)
      PutMsg(Port_B,(<span class="kw">struct</span> Message *) &amp;myMsg);
  }
  Permit();

  WaitPort(Port_A);
  GetMsg(Port_A);
}          </code></pre>
<p>The most perceptive readers might have surely noticed the instructions:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> Process *this = (<span class="kw">struct</span> Process *) FindTask(NULL);
<span class="kw">struct</span> MsgPort *Port_A =(<span class="kw">struct</span> MsgPort *) &amp;this-&gt;pr_MsgPort;</code></pre>
<p>As we should know by now, a task is a structure containing a reference to a task, generic in this case; in an application as those shown in this guide, once we execute our program it will be shown in the memory as a task. Calling FindTask() with a NULL parameter will simply return the pointer to our program task but, since our program IS a process, then all the fields of the Process structure just initialised will be valid. Of course, in order for this procedure to work we need to be sure that our program in memory is a process, but this happens in the majority of cases... A process includes a message port assigned at its creation, therefore the second instruction is also valid.</p>
<p>Now, if everything worked fine the task B has received on its Port_B our message. For Your Information at this point the task B has several ways to handle the message queue in its port (and on others eventually).</p>
<p>Now we are going to show the procedure offered by MUI.</p>
<h3 id="muim_application_addinputhandler-and-muim_application_reminputhandler">5.3.5 MUIM_Application_AddInputHandler and MUIM_Application_RemInputHandler</h3>
<p>The notions from the previous paragraphs helps us to be able to solve the problem of two tasks communicating between each other. MUI programming adds to the knowledge learned so far the possibility to encapsulate the IPC communication processed according to OOP criteria using for that purpose the MUIM_Application_AddInputHandler. Basically, the method MUIM_Application_AddInputHandler allows us to handle an eventual answer from task B inside our own method instead of bloat the main cycle of our application B with extra controls (see paragraph 4.5.2).</p>
<p>The method hooked to the Port_B through MUIM_Application_AddInputHandler will return TRUE if it accomplished succesfully all of its operations, otherwise obviously it will return FALSE.</p>
<p>Let's first define in the data area of our own MUIC_Application subclass something like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> appData
{
  ...

  <span class="kw">struct</span> MsgPort *Port_B;

  ...

  <span class="kw">struct</span> MUI_InputHandlerNode appHandler;   

  ...

 };
 
MUI_InputHandlerNode is a supporting structure composed as:
 
<span class="kw">struct</span> MUI_InputHandlerNode
{
    ...

    Object        *ihn_Object;

    <span class="kw">union</span>
    {
      ULONG ihn_sigs;
      
      ...
    
    } ihn_stuff;

    ULONG          ihn_Flags; 
    ULONG          ihn_Method;
};

<span class="ot">#define ihn_Signals ihn_stuff.ihn_sigs</span></code></pre>
<p>Let's enhance the fact that:</p>
<ul>
<li>ihn_Object : will contain the pointer to an object, in example instantiated from our MUIC_Application subclass;</li>
<li>ihn_Signals : will contain the associated signals to our Port_B (mp_SigBit);</li>
<li>ihn_Method : will contain the symbolic reference to our method assigned at message receiving;</li>
<li>ihn_Flags : will conatins a value that will notify MUI each time we will need to control a port, usually when set to 0;</li>
</ul>
<p>Under those conditions, usually, inside our method OM_NEW, will we have something that looks like:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> IPTR mNew(<span class="kw">struct</span> IClass *cl,Object *obj,<span class="kw">struct</span> opSet *msg)
{  
  [INITIALISATION]
  ...

  <span class="kw">struct</span> appData *data = INST_DATA(cl,obj);
  <span class="kw">struct</span> Process *this = (<span class="kw">struct</span> Process *) FindTask(NULL);
  data-&gt;Port_B         = (<span class="kw">struct</span> MsgPort *) &amp;this-&gt;pr_MsgPort;             

  memcpy(data,&amp;temp,<span class="kw">sizeof</span>(*data));                         

  ...

  data-&gt;appHandler.ihn_Object  = obj;
  data-&gt;appHandler.ihn_Signals = 1L&lt;&lt;data-&gt;Port_B-&gt;mp_SigBit;
  data-&gt;appHandler.ihn_Method  = MUIM_appSubClass_MyReplyMethod;
  data-&gt;appHandler.ihn_Flags   = <span class="dv">0</span>;
 
  DoSuperMethod(cl,obj,MUIM_Application_AddInputHandler,(ULONG)&amp;data-&gt;appHandler);


  ...

  <span class="kw">return</span> (IPTR)obj;
}  </code></pre>
<p>The description is quite simple: in our example it is only missing the implementation of our method MUIM_appSubClass_MyReplyMethod, that might look like:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> IPTR mMyReplyMethod(<span class="kw">struct</span> IClass *cl,Object *obj,<span class="kw">struct</span> MUIP_appSubClass_MyReplyMethod  *msg)
{
  <span class="kw">struct</span> appData *data = INST_DATA(cl,obj);
  IPTR ret = <span class="dv">0</span>;

  <span class="kw">if</span> (data-&gt;Port_B)
  {
    <span class="kw">struct</span> MyMessage *mex;

    <span class="kw">while</span>((mex = (<span class="kw">struct</span> MyMessage *)GetMsg(data-&gt;Port_B)) != NULL)
    {
      <span class="kw">if</span>([CHECK IF VALUES INSIDE THE MESSAGE ARE VALID])
      {
        ...
      }
      
      ReplyMsg((<span class="kw">struct</span> Message *)mex);        
      ret = (IPTR) TRUE;
    }
  }

  <span class="kw">return</span> ret;
}        </code></pre>
<p>Then, in the closing phase, inside the OM_DISPOSE method we will remove the link that we made, using the MUIM_Application_RemInputHandler:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> IPTR mDispose(<span class="kw">struct</span> IClass *cl,Object *obj,Msg msg)
{
    <span class="kw">struct</span> appData          *data = INST_DATA(cl,obj);
    
    ...

   
    DoSuperMethod(cl,obj,MUIM_Application_RemInputHandler,(ULONG)&amp;data-&gt;appHandler);
    
    ...

    <span class="kw">return</span> DoSuperMethodA(cl,obj,msg);
}             </code></pre>
<h2 id="introduction-to-sub-processes">5.4 Introduction to Sub-processes</h2>
<p>In many situations it might happen the need to wait for some resources to become available or it might also happen the need to interact with some devices that are slower compared to the execution of one of our own tasks. In similar conditions, if our program is busy doing a task, it might hinder the user's capacity to accomplish other tasks - in other words the program will show a &quot;busy&quot; state unresponsive to any expected output that prevents the user from doing further operations, at least until the perviously started task is finished.</p>
<p>Under normal conditions our program is an unique process in charge to handle both the user interface input and all the features available to the user, which can be done sequentially. When the operations involve CPU use only, through the scheduling techniques available through the operating system and the new processor's power, those operations might look almost immediate, with all operations apparently executed in parallel together, but the reality is different. If devices or resources are slower than a CPU involved, such as long disk operations or accessing a printer or so on, the involved task starts a cycle that contains several wait states, in which the resource access permissions are checked; of course a similar situation cannot allow the task to give an adequate possibility of action to the user. In situations similar to the above the best course of action is to encapsulate the most heavy procedure and make it run from another parallel process, so to release the main process from the burden and allow it to handle other stuff, such as handling user actions. to obtain this result is possible with the use of the CreateNewProc() call. The communication between main process and secondary process will be described according to the IPC standard already described in the paragraphs above.</p>
<h3 id="introduction-to-createnewproc">5.4.1 Introduction to CreateNewProc()</h3>
<p>The CreateNewProc() function and its variable parameters version CreateNewProcTags() allows a running program to generate a new task that shares the local variables, the current directory and the priority together with the main task. This situation is, obviously, configurable through special parameters, passed through tags to the CreateNewProc() function; furthermore, together with the traditional Amiga OS 3.x parameters - kept for compatibility reasons and that might come in handy in some circumstances - every other incarnation of Amiga OS add several new tags. Here only the most essential and common tags to create and handle a task in a portable way through all Amiga OS's will be described: for further details the reader is invited to look carefully at the CreateNewProc() documentation of the Amiga-like system of choice.</p>
<p>In order to create a new task at least a standard C function is needed: that function will impersonate our process and will be passed as a parameter (NP_Entry) to the CreateNewProc() function.</p>
<p>The standard declaration function to be fed to CreateNewProc() is the following:</p>
<pre class="sourceCode c"><code class="sourceCode c">ULONG subproc(STRPTR args, ULONG length)</code></pre>
<p>Despite the standard function declaration to be passed in CreateNewProc() in Amiga OS 4 it will instead look like:</p>
<pre class="sourceCode c"><code class="sourceCode c">int32 subproc(STRPTR args, int32 length, APTR execbase)</code></pre>
<p>and in MorphOS will look like:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> subproc(<span class="dt">void</span>) </code></pre>
<p>the first declaration above is supported in all systems for compatibility reasons; the only thing that concerns the operating system is the function return; it will need to match one of the AmigaDOS codes contained in &lt;dos/dos.h&gt;: RETURN_OK, RETURN_WARN, RETURN_FAIL, RETURN_ERROR.</p>
<p>The CreateNewProc() function relative options are contained as tags inside the &lt;dos/dostags.h&gt; header; it is better to view it together with the dos library autodoc.</p>
<p>Considered that in this case our purpose for a new task is to delegate operations such as interacting with slow devices, it might be useful to set it at a lower priority than the main task; to do that, the NP_Priority tag can be used.</p>
<p>In MorphOS an important CreateNewProc() tag is NP_CodeType, that needs to be set to the special value CODETYPE_PPC - it will tell the system that a new PPC native task will be launched.</p>
<p>Another important tag, this time under AmigaOS4, is the NP_Child tag: if set to TRUE will tell the system that the starting task is a child of the main task.</p>
<p>Summarising, the code will look like this:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifndef __MORPHOS__</span>
<span class="ot">#define NP_CodeType TAG_IGNORE</span>
<span class="ot">#define CODETYPE_PPC TRUE</span>
<span class="ot">#endif</span>

<span class="ot">#ifndef __amigaos4__</span>
<span class="ot">#define NP_Child TAG_IGNORE</span>
<span class="ot">#endif  </span>


ULONG subProcess(<span class="dt">void</span>)
{
    ...

    <span class="kw">return</span> RETURN_OK;
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="kw">struct</span> Process *pr;
    ...

  
    <span class="kw">if</span> (pr = CreateNewProcTags(NP_Entry, subproc,
                                   NP_CodeType,CODETYPE_PPC,<span class="co">//on MorphOS</span>
                                   NP_Child, TRUE,          <span class="co">//on AmigaOS4</span>
                                   NP_Priority,-<span class="dv">5</span>, 
                               TAG_DONE))
    {
        ...
    }

    ...

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h3 id="asynchronous-communication-a-practical-example">5.4.2 Asynchronous Communication, a practical example</h3>
<p>Let's suppose we have a subclass of MUIC_Application and that we need to launch a sub-task from it. All we really need at this point will be some data structures inside our subclass data area, obviously a function to use as a subprocess - called subProcess() and at last a method to use to initialize all the datas and call CreateNewProcTags(), in our example the method MUIM_MyClass_LaunchSubProc. The sub-task needs to do its own operations in a way that does not slow down the main program operations; therefore we will need to communicate asynchronously with the main program, using for the purpose:</p>
<ul>
<li>a private communication port for any incoming answers that the main program might receive from the sub-task (myPort);</li>
<li>the system's port assigned to the sub-task as mailbox where the main task will send its messages for the sub-task;</li>
<li>a structure to be used as IPC message between our main task and the sub-task (Mymsg);</li>
<li>the MUIM_Application_AddInputHandler and MUIM_Application_RemInputHandler methods already explained above (5.3.5);</li>
<li>a support method for the answers from the main task, in example a MUIM_MyClass_FreeResources;</li>
</ul>
<p>The communication process is identified from the value of a status variable inside the IPC message, and essentially acts as follows:</p>
<ol style="list-style-type: decimal">
<li>the main process launches the subprocess and asks to execute what it is supposed to (status = PLEASE_EXECUTE_YOUR_WORK);</li>
<li>the sub-process does its job, but requests something from the main process (status = MAINPROC_I_WANT_SOMETHING);</li>
<li>the main process provides an adequate answer to the sub-process (status HERE_I_GIVE_YOU_WHAT_YOU_WANT);</li>
<li>the sub-process finishes the last part of the job and warns the main process that it has accomplished all of the job queue (status = QUIT);</li>
<li>the main process is finally free to remove from memory all unnecessary resources;</li>
</ol>
<p>It is important to note that the end of a sub-task always includes a Forbid() call before the canonic ReplyMsg() call. This Forbid() call is required to tell the system to not execute a context change before the sub-task finishes completely its job - in this case the ending code. Why do we need a call like this? Well, let's rethink about the way we created our sub-process that, for its own nature, is a kind of main process extension and shares with it some essential data, like the libraries base and something else. The main process might close before one of the sub-process and leave it without an essential chunk of required data, that is the reason for the Forbid() call: it allows the system to close the sub-process before the main process. Under Amiga OS 4 the Forbid() call is superfluous in case the NP_Child tag is set to TRUE: in this case there will be the system itself to take care not to close the main process before our created sub-process.</p>
<p>The code is the following:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*****************************************************************************/</span>
<span class="ot">#ifndef MEMF_SHARED</span>
<span class="ot">#define MEMF_SHARED MEMF_PUBLIC</span>
<span class="ot">#endif</span>

<span class="kw">enum</span> {   
    PLEASE_EXECUTE_YOUR_WORK=<span class="dv">1</span>,
    MAINPROC_I_WANT_SOMETHING,
    HERE_I_GIVE_YOU_WHAT_YOU_WANT,
    QUIT
};  


<span class="kw">struct</span> myData
{
    <span class="kw">struct</span> MsgPort              *myPort;
    <span class="kw">struct</span> Process              *mySubProc;
    <span class="kw">struct</span> MUI_InputHandlerNode myHandler;

    ...
};


<span class="kw">struct</span> Mymsg
{
  <span class="kw">struct</span> Message  msg;

  ...

  LONG            status;
};
<span class="co">/*****************************************************************************/</span>

<span class="co">/*****************************************************************************/</span>
<span class="co">///subProcess()</span>
<span class="dt">int</span> subProcess(<span class="dt">void</span>)
{
    LONG  wrap;
    STRPTR font;
    <span class="kw">struct</span> Process *pr = (<span class="kw">struct</span> Process *) FindTask(NULL);
    <span class="kw">struct</span> printmsg *mex = NULL;


    <span class="ot">#ifdef __MORPHOS__</span>
    <span class="kw">struct</span> ExecBase *SysBase = *(<span class="kw">struct</span> ExecBase **) <span class="dv">4</span>;
    <span class="ot">#endif</span>

    WaitPort (&amp;pr-&gt;pr_MsgPort);

    <span class="kw">while</span> (!mex)
        mex =(<span class="kw">struct</span> printmsg *) GetMsg(&amp;pr-&gt;pr_MsgPort);

    <span class="kw">if</span> (mex-&gt;status == PLEASE_EXECUTE_YOUR_WORK)
    {
      ...

      mex-&gt;status = MAINPROC_I_WANT_SOMETHING;
      ReplyMsg ((<span class="kw">struct</span> Message *)mex);

      mex = NULL;
      <span class="kw">while</span> ( !(mex = (<span class="kw">struct</span> Mymsg *)GetMsg (&amp;pr-&gt;pr_MsgPort)) )
          WaitPort (&amp;pr-&gt;pr_MsgPort);     <span class="co">//wait for reaction from main task</span>
    }
    <span class="kw">else</span> <span class="kw">if</span> (mex-&gt;status == HERE_I_GIVE_YOU_WHAT_YOU_WANT)
    {
      ...
    }

    ...

    mex-&gt;status = QUIT;
    <span class="ot">#ifndef __amigaos4__</span>
    Forbid();
    <span class="ot">#endif</span>
    ReplyMsg ((<span class="kw">struct</span> Message *)mex);


    <span class="kw">return</span> RETURN_OK;
}
<span class="co">///</span>
<span class="co">/*****************************************************************************/</span>

<span class="co">/*****************************************************************************/</span>
<span class="co">///MUIM_MyClass_LaunchSubProc</span>
<span class="dt">static</span> IPTR LaunchSubProcMethod(<span class="kw">struct</span> IClass *cl,Object *obj, Msg msg)
{
    <span class="kw">struct</span> myData    *data = INST_DATA(cl,obj);
    <span class="kw">struct</span> Mymsg   *mex;

    <span class="kw">if</span> (data-&gt;myPort)
    {
        MUI_RequestA(obj,NULL,<span class="dv">0</span>,
                        (<span class="dt">char</span> *)<span class="st">&quot;Requester&quot;</span>,
                        (<span class="dt">char</span> *)<span class="st">&quot;Ok&quot;</span>,
                        (<span class="dt">char</span> *)<span class="st">&quot;Just in running...&quot;</span>,
                     NULL);

        <span class="kw">return</span> (IPTR) FALSE;
    }

    data-&gt;mySubProc=NULL;

    <span class="kw">if</span> ((mex = AllocVec (<span class="kw">sizeof</span>(<span class="kw">struct</span> Mymsg),MEMF_CLEAR|MEMF_SHARED)))
    {
        <span class="kw">if</span> ((data-&gt;myPort = CreateMsgPort()))
        {
            <span class="kw">if</span>((data-&gt;mySubProc = CreateNewProcTags(NP_Entry, (ULONG) subProc,
                                                      NP_CodeType,CODETYPE_PPC,<span class="co">//on MorphOS</span>
                                                      NP_Child, TRUE,          <span class="co">//on AmigaOS4</span>
                                                      NP_Priority,-<span class="dv">5</span>,
                                                    TAG_DONE)))
            {
                data-&gt;myHandler.ihn_Object   = obj;
                data-&gt;myHandler.ihn_Signals  = 1L&lt;&lt;data-&gt;myPort-&gt;mp_SigBit;
                data-&gt;myHandler.ihn_Method   = MUIM_App_FreeResources;
                data-&gt;myHandler.ihn_Flags    = <span class="dv">0</span>;
               
                DoSuperMethod(cl,obj,MUIM_Application_AddInputHandler,(IPTR)&amp;data-&gt;myHandler);

                ...

                mex-&gt;status = PLEASE_EXECUTE_YOUR_WORK;
                mex-&gt;msg.mn_ReplyPort = data-&gt;myPort;
                
                <span class="co">/* establish communication with sub task */</span>
                PutMsg (&amp;data-&gt;printSubProcess-&gt;pr_MsgPort,(<span class="kw">struct</span> Message *)mex);   
            }
        }
    }


    <span class="kw">return</span> (IPTR) TRUE;
}
<span class="co">///</span>
<span class="co">/*****************************************************************************/</span>

<span class="co">/*****************************************************************************/</span>
<span class="co">///MUIM_MyClass_FreeResources</span>
<span class="dt">static</span> IPTR FreeResourcesMethod(<span class="kw">struct</span> IClass *cl,Object *obj,Msg msg)
{
    <span class="kw">struct</span> myData *data = INST_DATA(cl,obj);
    IPTR ret = FALSE;

    <span class="kw">if</span> (data-&gt;myPort &amp;&amp; data-&gt;mySubProcess)
    {
        <span class="kw">struct</span> Mymsg *mex = NULL;

        <span class="co">/* wait for reply from sub proc */</span>
        <span class="kw">while</span>((mex = (<span class="kw">struct</span> Mymsg  *)GetMsg(data-&gt;myPort)) != NULL)
        {

            ...

            <span class="kw">if</span> (status == MAINPROC_I_WANT_SOMETHING)
            {
              ...

              mex-&gt;status = HERE_I_GIVE_YOU_WHAT_YOU_WANT;
              mex-&gt;msg.mn_ReplyPort = data-&gt;myPort;

              <span class="co">/* reply to sub proc*/</span>
              PutMsg (&amp;data-&gt;mySubProcess-&gt;pr_MsgPort,(<span class="kw">struct</span> Message *)mex);

              ret = TRUE;
              <span class="kw">break</span>;
            }
            <span class="kw">else</span> <span class="kw">if</span> (mex-&gt;status==QUIT)
            {
               
                DoSuperMethod(cl,obj,MUIM_Application_RemInputHandler,(IPTR)&amp;data-&gt;myHandler);

                DeleteMsgPort(data-&gt;myPort);

                data-&gt;myPort=NULL;


                FreeVec(mex);

                ret = TRUE;
                <span class="kw">break</span>;
            }
        }
    }

    <span class="kw">return</span> ret;
}
<span class="co">///</span>
<span class="co">/****************************************************************************/</span></code></pre>
<h1 id="methodology-for-planning">Methodology for planning</h1>
<p><em>&quot;Voodoo programming: The use by guess or cookbook of an obscure or hairy system, feature, or algorithm that one does not truly understand. The implication is that the technique may not work, and if it does, one will never know why. Almost synonymous with black magic, except that black magic typically is not documented and nobody understands it.&quot;</em> The Jargon File</p>
<p><em>&quot;black magic: A technique that works, though nobody really understands why.&quot;</em> The Jargon File</p>
<h2 id="defining-a-problem-to-solve">6.1 Defining a problem to solve</h2>
<p>Now let's proceed to an explanation (rather small) of macro-analysis. To be covered are some practical examples for each phase.</p>
<p>One of the key parts in the design of a software is to understand what we want to solve and consequently develop. For such wishes:</p>
<p><em>&quot;Amiga write a program that emulates a calculator. The program will display an addition, subtraction, multiplication, a division, square root.</em></p>
<p>We must first understand &quot;what we want&quot; from our program, its purpose. In our case there are many kinds of Calculators: simple calculators, scientific calculators, evolutionary calculators, and so on. In the example shown we develop a calculator with basic functions. But what are the functions based on for a calculator? To obtain answers to the latter, the application must be documented. The stage of documentation is essential to define everything that the software will have to offer and therefore it must take some time to find information about the problem solve, in the jargon necessary to understand the &quot;domain&quot;, ie the environment surrounding the issue. In our case, apparently simple, we documented the performance of an addition, subtraction, multiplication and a square root of one or more numbers within the calculator. At this point we have identified the things necessary, at this stage, about the &quot;simple calculator. Having acquired a certain cultural background on the problem to solve, we proceed to define the so-called &quot;requirements&quot;, ie functionality that the software will have to offer.</p>
<p>Some requirements are &quot;cast&quot;:</p>
<p><em>&quot;The program will perform an addition, subtraction, a multiplication, division, square root.</em></p>
<p>Some are &quot;explicit&quot;</p>
<p><em>&quot;The program should be able to enter negative numbers, the user can enter numbers with the comma, should have the ability to clear the display from previous operations, should be able to handle the division by zero and finally the program needs a graphic interface.</em></p>
<p>Other requirements are implicit:</p>
<p><em>&quot;The program will run on the various incarnations Amiga. The interface graphics should look like a real calculator. The program will allow viewing and manipulation of TOT digits.</em></p>
<p>We have thus defined the &quot;Problem&quot;.</p>
<p>The definition of requirements will lead to further work, documentation from the developer, who will then search for information about the requirements explicit and implicit. All information obtained from this research will then be used in subsequent phases of macro-analysis.</p>
<h2 id="analysis-and-specification-requirements">6.2 Analysis and specification requirements</h2>
<p>Requirements analysis is the most important step during the development of software, at this stage are formalized features identified during the definition of the problem. More precisely, formalize two families of requirements</p>
<ul>
<li>Functional requirements: they represent what the software must do;</li>
<li>Non-functional requirements: they are constraints, constraints which software must undergo;</li>
</ul>
<p>Among the non-functional requirements we can distinguish:</p>
<ul>
<li><p>Requirements process: they include the timing of delivery of software, standards to be met, the operating systems on which the software should be executed, the languages to be used for encoding;</p></li>
<li><p>Product requirements: they include fees for the software that should be expected. Those fees have reliability, portability, usability and many others;</p></li>
<li><p>External requirements are the constraints of legal order and economic development;</p></li>
</ul>
<p>Anyway it is good to assign to each requirement its own priorities. The priority of the requirement is given according to their degree of importance with respect to the completeness of the project. Specifically, the requirements are classified according to three priorities:</p>
<ol style="list-style-type: decimal">
<li>MUST: are requirements whose failure would jeopardize implementation functioning of the entire software;</li>
<li>Should: have implemented requirements that would give greater completeness of the software. Their failure to implement would not affect any basic functionality of the software. However, the requirements SHOULD could be implemented at a later time without loss of much time and without modifying the source code;</li>
<li>MAY: requirements whose implementation is optional and you can do without a first phase of software development. However, the addition of these functionality at a later time may change parts significantly in the software, having to spend so much time for their implementation;</li>
</ol>
<p>Now we apply these theories to our example. The Problem was:</p>
<p><em>&quot;On the Amiga write a program that emulates a calculator. &quot;The program will perform addition, subtraction, multiplication, division, square root &quot;.&quot; the program should be ability to enter negative numbers, the ability to enter numbers with the comma, the ability to clear the display by previous operations I / O. The software should be able to manage division by zero and as a last thing, the program will require a graphical interface. The program will display and TOT manipulating figures. The program will run on different Amiga incarnations. The graphical interface should look like a real calculator.</em></p>
<p>Those requirements, combined with the documentation that we obtained during our research today:</p>
<p>Functional Requirements</p>
<p>MUST: The program will allow the inclusion of these numbers by user. The numbers appear in a special area display (display);</p>
<p>MUST: The program should perform the arithmetic operation of addition. Given two real numbers a and b, the operation &quot;+&quot;, will give us, if it is computable from 'processor, a third number c = a + b;</p>
<p>MUST: The program should perform the arithmetic subtraction. Given two real numbers a and b, the operation &quot;-&quot; will give us, if be calculated the generation, third number c = ab;</p>
<p>MUST: The program should perform the arithmetic multiplication. Given two real numbers a and b, the operation &quot;x&quot;, will give us, if it is calculated by the 'processor, a third number c = axb;</p>
<p>MUST: The program should perform the arithmetic operation of division. Given two real numbers a and b, the operation &quot;/&quot;, will give us, if it is computable the generated, third number c = a / b. The program will also manage the division by zero in an appropriate manner;</p>
<p>MUST: The program will perform the operation square root. Since a real number a, the operation or the square root &quot;sqrt&quot;, will, generate a third calculation, third number c = SQRT (a);</p>
<p>MUST: The program must explicitly allow you to add figures less than 1 to a positive number that has been typed by the use of symbol &quot;,&quot;;</p>
<p>MAY: The program must explicitly allow you to change the sign of a number you enter, more precisely you can choose two signs and that is &quot;+&quot; for positive numbers (typical case), or &quot;-&quot; by the numbers negative. This program is another way to manipulate positive numbers as negative numbers;</p>
<p>Should: The program should explicitly allow the user to clear the display from previous operations I / O;</p>
<p>Non-functional requirements</p>
<p>Requirements Process</p>
<p>MUST: The program will be implemented using C language, using the API MUI / Zune for the GUI;</p>
<p>MUST: The program allows viewing and manipulation 14 (limit of the calculator included in AmigaOS) figures.</p>
<p>Product requirements</p>
<p>MUST: The program will be implemented using the SDI headers to ensure its portability among different Amiga incarnations (AmigaOS3.x, AmigaOS4, MorphOS, AROS);</p>
<p>MUST: The graphical interface should have the appearance and usability of a real calculator</p>
<h3 id="levels-of-requirements-definition">6.2.1 Levels of requirements definition</h3>
<p>To formalize clearly all the requirements of a software achieved, you can define two levels of definition:</p>
<ol style="list-style-type: decimal">
<li>In the first level requirements are expressed in colloquial language and through diagrams (UML);</li>
<li>In the second level are specified by the arguments expressed in the first level using technical languages;</li>
</ol>
<p>From these two levels is obtained a document called Document Specifying Requirements (DSR), or even Specify Require Software (SRS), in which requirements are expressed clearly, correctly and without contradictions or ambiguities.</p>
<h3 id="use-cases-in-colloquial-language">6.2.2 Use Cases in colloquial language</h3>
<p>Use cases illustrate the possible situations of use of software. Each use case typically focuses on one of the requirements functional, deepening and detailing the different interactions that the software would have with the user in that particular situation. Each use case contains one or more scenarios. A scenario is an alternative ways to interact with a feature of the software it lists what could happen and can write each scenario at the model &quot;storyboard&quot;, essentially a list of steps, expressed in language colloquial, carried by the user and answers provided by the software. For use cases it is usually the following rule:</p>
<p>Functional requirement of priority MUST -&gt; Use Case;</p>
<p>In our simple example [file use_Case.txt attached to this chapter] will convert even the functional requirements SHOULD and MAY into use cases, usually this is not done because the requirements analysis focuses more on the functional requirements of priority MUST.</p>
<h3 id="uml-and-use-cases">6.2.3 UML and use cases</h3>
<p>With regard to the UML, namely, Unified Modeling Language, it should be a good source of documentation:</p>
<pre><code>http://en.wikipedia.org/wiki/Unified_Modeling_Language</code></pre>
<p>Now to summarize the basic concepts. After expressing in a formal way and the requirements of our ambiguous software, we describe these requirements through graphics. This graphical representation is obtained through the UML. The end result will be known as a &quot;use case diagram.&quot; This diagram should always be intuitive to understand, therefore, not be too complicated. Diagram use case is used by designers to get a better clear that which is the project to be developed. A case diagram you can use intuitively to represent the functionality of software and how these may depend on each other. Such a vision could lead to discussions that will come to the best possible solutions and corrections to the requirements set out so far.</p>
<p>First of all our software in UML is represented graphically by a rectangle, which &quot;borders&quot; so-called use cases.</p>
<p>To switch from functional requirements to use cases are procedures that we will now describe.</p>
<p>UML allows us to graphically represent each use case by an ellipse;</p>
<p>In the diagrams of use cases is a key figure the 'actor': an entity external to the software that performs a specific active role; UML graphically represents an actor with a little man stylized;</p>
<p>In our case, very simple, we have:</p>
<p>Our example defines the use cases within the system &quot;Calculator&quot;, our actor is the user. Given that the system gives the user a chance to interact with its features so many times as they choose, only in this case can you tell that this interaction with a single line that is connected to the &quot;subsystems&quot;, which bring together some features. We grouped in our case features &quot;Main&quot; and &quot;Support&quot;. The arrow labeled &quot;uses&quot; indicates that the Use Case &quot;Viewing Issue Type&quot; is used by all the cases with the arrow pointing in our case.</p>
<h2 id="design">6.3 Design</h2>
<p>Having clear, detailed and unambiguous plans so all the requirements in the previous step you can switch to the design of the software.</p>
<p>The design phase is the bridge between requirements analysis and encoding the same source code of our software. The result of this phase is the &quot;document design specification&quot;, or DSP, which describes how to implement the requirements of the previous phase. The objective of the project is to produce software that respects qualities such as modifiability, understandability and reusability. The tendency of software engineers is increasingly to design a system that addresses the achievement of requirements set by a breakdown in independent parts, in other words a modularized system. There are several modularization techniques, in our example we will use the TOP-DOWN philosophy, in which the initial problem is decomposed into subproblems treated as independently as possible. Each subproblem is solved within a module. Each form must be seen from outside as a &quot;black box&quot; accessible only through the services it will provide. A module is essentially composed of two parts:</p>
<ul>
<li><p>An interface is visible outside the module, which represents services provided by the module to other modules;</p></li>
<li><p>The implementation, hidden outside, which represents the implementation details of the module. Inside deployment are algorithms, data structures and policies of use and resources with which the module is able to provide their services;</p></li>
</ul>
<p>In programming languages the concept of a module is identified with the function, although the object-oriented languages offers the most powerful tools to make a modularization of the system.</p>
<h1 id="appendix-b-subversion-on-amiga">APPENDIX B: Subversion on Amiga</h1>
<p><em>&quot;And given how Amiga software looks today, it appears to me that not everyone who should have read this book really did know.&quot;</em> Olaf Barthel about the book &quot;The User Interface Style Guide&quot;, 26/11/1996 comp.sys.amiga.programmer</p>
<p><em>&quot;It's really high time the RKMs are taken care of.&quot;</em> Olaf Barthel comp.sys.amiga.programmer 12/09/1997</p>
<h2 id="b.1-introduction">B.1 Introduction</h2>
<p>Subversion is a set of programs that allows different developers to work simultaneously with one or more files. Using Subversion is also recommended in projects where working as a single person, because the use of these programs involves a number of advantages:</p>
<ul>
<li><p>The ability to edit any file in real time anywhere;</p></li>
<li>The ability to maintain different versions on synchronized different machines automatically and without bothering to copy from one machine to another, the latest version;</li>
<li><p>The possibility of returning to earlier revisions of their work at any time, instead of going crazy trying to remember what changes were made from some period onwards;</p></li>
</ul>
<p>We can therefore define Subversion as a set of programs for clean and transparent management of its work.</p>
<p>The interaction between different users within the same project is through a main server, which receives project files with whom they are collaborating. A user downloads onto their computer a file copy of the project in which they are interested in, making their changes and then sends them to the main server, Subversion will then integrate them properly with the version of project resident on the server.</p>
<h2 id="b.2-what-is-a-repository">B.2 What is a repository</h2>
<p>Subversion is a system for sharing information that works using a data store, in the jargon &quot;repository&quot;. Repository stores information hierarchically, being used as our computer files and directories. One or more computers can connect to the repository and read or write these files. Obviously the repository is located on a remote server.</p>
<h2 id="b.3-what-is-a-review">B.3 What is a review</h2>
<p>One of the concepts that underpins the functioning of Subversion is that of revision. Suppose we have on our Amiga a text file, pippo_r0.txt, and then go and edit, then save the edited file with another name, for example pippo_r1.txt. We will in this situation have two files, separate from the fact that the second represents a modernized version of the first. File pippo_r0.txt 0 we can define the revision of our files, while pippo_r1.txt is identifiable as the revision 1 of the same file. A review is therefore a copy, or rather a &quot;snapshot&quot; (snapshots) than one file at a given moment of its existence. Each time we send successfully a change to the files of a project managed on a server to Subversion, the repository will be responsible for creating a revision of the file before our changes, so that allow us to recover any of the work done before accidental loss. This is one of the strengths of projects using Subversion: the ability to recover any data when a review of one or more files of a project without tasking our computer to manage different copies manually. As mentioned, those who perform the operations and maintenance control revisions in the repository, which remembers every change has been made in it: it will consider any change made to every file and directory. When a computer reads the data from the repository, normally seeing only the latest revision of the directory tree. In reality, it also has the chance to see a previous review of the tree directory.</p>
<h2 id="b.4-collaborate-in-projects-that-use-subversion">B.4 Collaborate in projects that use Subversion</h2>
<p>To collaborate on a project that uses Subversion you only have to have an account on the server that hosts the project and the Subversion package installed on your Amiga. Usually all of these programs are on Aminet, os4depot and other sites of this kind.</p>
<h2 id="b.5-command-svn">B.5 Command SVN</h2>
<p>The suite contains a number of Subversion commands to be given to the Shell, SVN is one of the main. The SVN command controls most of the actions used to collaborate in a project already started. Of particular relevance is the version of svn and the server with which you interact. More specifically, some new servers, such as code.google.com, require identification through SSL, which is supported in the Amiga version 1.7 of Subversion (a port of version 1.1.4), So if you have a version earlier than 1.7 you cannot access projects that reside on this server from your Amiga. As mentioned, the command svn allows enough interaction to complete existing projects, using appropriate options among those offered by this command. Options used most frequently are:</p>
<ul>
<li>Checkout (or co): allows you to download to your harddisk all files of a project;</li>
<li>Diff: shows the differences between the local review (harddisks) and the Journal of the repository;</li>
<li>Update (or up): upgrade to the latest revision of a file copying project on your harddisk;</li>
<li>Resolved: alerts the server that we have eliminated the possible conflicts that were present in our local copy that prevented it to send / integrate their resident version on the repository design changes;</li>
<li>Revert: allows you to restore one or more local files replacing them with the files on the repository;</li>
<li>Add: shows which new files will be added to project's repository;</li>
<li>Delete: indicates which files will be removed from a project's repository;</li>
<li>Commit: send your changes to the repository that will deal with integrity;</li>
</ul>
<h3 id="b.5.1-checkout-download-the-source-code-of-a-project">B.5.1 Checkout, download the source code of a project</h3>
<p>As we mentioned, the projects managed with Subversion reside on a server that supports this suite of programs. Among the most popular server we have those provided by portals and sourceforge.net, code.google.com, The first accepts and agrees for most software projects, while the second also hosts projects which are not necessarily the sources of software, but also documentation and guides works.</p>
<p>Suppose we want to collaborate on a project that resides on sourceforge portal, for example NoWinED. The web page of this project is:</p>
<pre><code>http://sourceforge.net/projects/nowined/</code></pre>
<p>This page has a series of choices to be made by the browser, including at the top is the link to &quot;Code&quot;. This link leads to a javascript menu on which are listed, among other items, SVN and SVN Browser. The second is simply a way to see parts of the code that make up the project directly from the browser, while The first link is what we are concerned with. After selecting SVN link from the site, we will enter a page that displays another link immediately preceded by the svn command. This string is what you type subsequently in our Shell. Attention, followed by the svn co will create the directory inside the current one in which the Shell is a directory containing all files the project is accessing, then before you type svn the Shell must position themselves exactly to the location where we want this directory to be created. Then write in the Shell:</p>
<pre><code>svn co https://nowined.svn.sourceforge.net/svnroot/nowined nowined</code></pre>
<p>After typing this command the program will download from the svn site all the files needed to create a working copy of the draft in which we participate, in our case, all files will be included in a directory named nowined.</p>
<p>We have therefore introduced a first parameter of the command svn co, or also checkout, which would serve to download from a repository all the files that make up a project, automatically creating all the necessary directories.</p>
<p>Typically the files that we are interested in are in the program directory / trunk /. Each project obviously has it's own directory structure within the trunk, for example NoWinED currently has two directories inside trunk.</p>
<p>Svn The command also creates in each directory private subdirectories that &quot;monitor&quot; further, called. &quot;svn&quot;. Just keep in mind that the directories by name. &quot;Svn&quot; are for Subversion to perform their duties and should not be modified or deleted.</p>
<h3 id="b.5.2-diff-preview-of-the-differences-between-local-files-and-review-the-repository">B.5.2 Diff, preview of the differences between local files and Review the repository</h3>
<p>After changing one or more files of a project, before sending the repository your changes, you may feel the need to view from a global point of view all of the changes you've made to the project. To achieve this the program svn can generate an output that displays all of our changes compared to the last revision of the project on the server.</p>
<p>Also, usually every project has the person which needs to review before sending your changes first. Such persons may require you to analyze your changes before eventual integration with the project.</p>
<p>To get a file containing the changes we have made simply type in the Shell, placed in the directory where you downloaded the project with svn:</p>
<pre><code>svn diff &gt; RAM: diff.txt</code></pre>
<p>In this way we will get in RAM: the file that will contain what diff.txt we need to reassure operators of the project which we want to cooperate.</p>
<p>The output has a similar option diff syntax:</p>
<pre><code>Index: file2
==================================================
--- File2 (revision 46)
+ + + File2 (working copy)
@ @ @ @ -1.7 +1.12


- LINE REMOVED
+ LINE ADDITION</code></pre>
<p>lines erased than copying the repository are preceded by a -, while the added lines are preceded by a +.</p>
<h2 id="b.5.3-update-update-their-local-files-to-the-latest-version">B.5.3 Update, update their local files to the latest version</h2>
<p>And 'good practice, prior to submission of amendments to main server, synchronize the files on your computer with those residing in the official repository of the project in which we're cooperating. The upgrade could save any estimate of problems of incompatibility between local files and those on the repository and above all else allows you to verify whether your changes are or not compatible with the latest version of the project we're working. To update our working copy with the one on the repository Just place go in the Shell to the directory that contains the project files we're working together and write:</p>
<pre><code>svn update</code></pre>
<p>or:</p>
<pre><code>svn up</code></pre>
<p>Option update (and up) allows you then to download files more updated by the server that maintains the official version of the project in which we cooperate. Subversion will synchronize all files if everything went through. If we wanted to retrieve from the server instead a particular revision of one or more files we should type:</p>
<pre><code>svn up-r numeroRevisione</code></pre>
<p>In this way we could retrieve such a file we accidentally overwrote on the same repository so as to restore any changes we made several revisions before and lost in the most recent revisions</p>
<p>B.5.4 Revert, resolve conflicts</p>
<p>A common enough occurrence when working on a project with Subversion is the possibility of incurring conflicts. Conflict occurs when a file has been modified locally, which in turn is changed even in its official version on the repository. Svn command during the update procedure warns us of conflicts through a particular symbology. If for example, we have updated three files to the repository, two of which were also modified locally we have a situation Similarly, displayed as output to Shell:</p>
<pre><code>:&gt; svn update
U file1
G file2
C file3
Updated to revision 46.</code></pre>
<p>We can see three codes output: U, G and C. U indicates that the files Rooms have been updated successfully, G indicates that the changes sent to the server have been successfully integrated with our modifications while C indicates that there was a conflict to be resolved manually before attempting to submit the changes to the repository. Subversion behaves differently depending on the nature of the conflict met.</p>
<p>In the case of minor changes, Subversion might consider such integration changes of the official version on the repository easily, For this purpose the program puts markers of conflict, which are simply special strings of text that surround the &quot;extreme&quot; of the problem within the file. Thus Subversion makes visible the changes of problems that can be integrated. In other words we will charged within a situation this:</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;. Landmines
Our changes
=======
OFFICIAL CHANGE
&gt;&gt;&gt;&gt;&gt;&gt;&gt;. R2</code></pre>
<p>In the case of larger conflicts, for each file in which a problem was detected, put in your Subversion working copy three extra files that are not under the control of the program:</p>
<p>file.mine: This is the file that was in the working copy first upgrade. This file contains the latest changes done and nothing else. (If Subversion considers the file not able to be integrated, then the file. mine is not created, because it could be identical to the working file);</p>
<p>file.OLDREV: This is the file that was checked out before recent changes we have made;</p>
<p>file.NEWREV: This is the file that has just been received from the server svn you did when you updated the working copy;</p>
<p>At this point, Subversion will not allow you to send any changes to the server until the three temporary files are removed.</p>
<p>We therefore must decide how to intervene to resolve conflicts: we will have to choose the most appropriate modification, eliminate what to discard, or combine in a single block / file both changes. You can also choose to discard your changes in favor of those in the revision of the file on the server, to obtain this just type:</p>
<pre><code>svn revert file</code></pre>
<p>So with the option remove revert our changes locally, the file locally will accept the version of the file on the repository.</p>
<p>After resolving the conflicts simply type:</p>
<pre><code>svn resolved</code></pre>
<p>to notify the repository that we have solved everything.</p>
<h3 id="b.5.5-add-and-delete-add-and-remove-files">B.5.5 Add and delete, add and remove files</h3>
<p>In the event that you have created new files to integrate into the project which you are working, svn offers the option svn add. With add it is reported that at the next commit changes to files on repository, will be added and also sent the new files. The managers of a project might want to see these new files, after using add, svn diff is invoked if the output of this option displays the changes between the content of the new file. If we want to point out the need for Subversion to remove some files from the project we're working together we type:</p>
<pre><code>svn delete fileCancelled</code></pre>
<h3 id="b.5.6-commit-sending-and-integration-of-changes">B.5.6 Commit, sending and integration of changes</h3>
<p>If all the steps described until now have been successful, and managers of the project have willingly accepted your changes by sending the differences (diff), it is time to send your changes to the repository. To achieve this move to the directory in the shell that contains the project files and type:</p>
<pre><code>svn commit-m &quot;commentoAlleMieModifiche&quot;</code></pre>
<p>The-m flag tells SVN to attach a comment to the modifications that they are sending to the official repositories, not mandatory, but strongly recommended in order to make others understand what our changes consist of. If you omit the-m flag a window will be opened of the program and where you must enter the edit comment. At this point, you may be asked the root password that is not usually possessed, just simply type send, then you will only require the first time your userid (the same as Your account on the server), and a password (which in the case of SourceForge is the password for your account, while in the case of Code. Google will be the one given to you by your project). This way your changes will represent the current review present in the repository.</p>
<h2 id="b.6-svnadmin-creation-of-own-projects">B.6 svnadmin, creation of own projects</h2>
<p>So far we have dealt only with how to interact with existing projects. If we wanted to create from scratch a new project that uses Subversion we will have to use another svn tool package, the command svnadmin. However, before using this command it is good to exhibit assumptions regarding the choice of the server to be used for their design and structure the directory you will create.</p>
<h3 id="b.6.1-server-custom-or-already-prepared">B.6.1 Server custom or already prepared?</h3>
<p>You can create your own project that uses Subversion and employs space usually provided by your ISP or other services such as Altervista, but such a choice involves a number of risks and limitations. The biggest problem with the choice of server is usually the obligation of having to install Apache, that serves in this case to restrict access to visitors, in so that the administrator of the server (ie us) is the only one able to possibly delete the repository. Without Apache anyone could destroy all of our work, we also have to have prior knowledge of the Apache package.</p>
<p>Fortunately, there are portals that make a specific server ready for use with Subversion, among them SourceForge and Code.Google are certainly the most known. Each these portals allows the administrator to easily set the rules of access to their projects, configure the visibility of files belonging to the project (for example if we had a closed source project we will not want to give access to its sources to everyone), the removal and addition of users who collaborate to project, and much more.</p>
<p>There are some differences between SourceForge and Code.Google:</p>
<ul>
<li><p>SourceForge allows users to send data using the sourceforge account password, and Code.Google provides a password auto generated and known only to the administrator;</p></li>
<li><p>SourgeForge does not accept projects that do not relate to programming in other words within the repository of SourgeForge are accepted only source files and the like. You are also obliged to choose a license from those listed or propose their own, but licenses such as Creative Commons will not be allowed to SourgeForge. All this does not exist on Code.Google;</p></li>
<li><p>Code.Google allows interaction with your server via SSL, So prior to version 1.7 of Subversion on Amiga not Code.Google work with, while on SourceForge it does not have these problems (yet);</p></li>
</ul>
<p>Code.Google provides a user-created tree for each project Directory typical of a SVN repository, and SourceForge requires more attention when the user will have to create its standard directory tree;</p>
<p>Once you choose the portal to use and have created the necessary account, the site will provide you a URL that will be the homepage of your project (see section B.5.1) in it as usual you will find links that will be used with the command svn (see section B.5.1) and also with the svnadmin command. For example, if the project was registered as &quot;MyProject&quot; in SourgeForge:</p>
<pre><code>https://nowined.svn.sourceforge.net/svnroot/MyProject</code></pre>
<p>while Code.Google you:</p>
<pre><code>https://myproject.googlecode.com/svn/trunk</code></pre>
<h3 id="b.6.2-preparing-the-necessary-files-and-creation-of-the-repository">B.6.2 Preparing the necessary files and creation of the repository</h3>
<p>To create our own repository you must first do these actions in the Shell. First, in RAM:</p>
<pre><code>cd RAM:</code></pre>
<p>At this point we create directories that will host temporarily our project:</p>
<pre><code>MAKEDIR temp
MAKEDIR temp/MyProject</code></pre>
<p>If the chosen server is provided by SourgeForge at this point must create other directories:</p>
<pre><code>MAKEDIR RAM:temp/MyProject/branches
MAKEDIR RAM:temp/MyProject/tags
MAKEDIR RAM:temp/MyProject/trunk</code></pre>
<p>This guide is does not presently discuss in detail the use of these three directories, so for further information you should refer to the complete guide for Subversion (http://svnbook.red-bean.com/nightly/it/svn-book.html), suffice it to say the trunk directory will contain all the files in your project while branches and tags directories will remain (for now) empty. Directories branches, tags, and trunk are not actually required by Subversion, they simply represent a common convention most likely to be followed.</p>
<p>It is time to create a temporary directory destination (temporary repository):</p>
<pre><code>MAKEDIR RAM:svnroot</code></pre>
<p>At this point you can put all the files in your project within ram:temp/MyProject/trunk/. Now it is possible to create the actual repository:</p>
<pre><code>svnadmin create /ram/svnroot/repos</code></pre>
<p>Finally, we must import all the files in the remote repository that we created so far, to the URL we use for our SVN server (section B.6.1):</p>
<pre><code>svn import /ram/temp/MyProject URL_DEL_VOSTRO_PROGETTO -m &quot;initial import&quot;</code></pre>
<p>During these steps you may be requested to login, that which we have already described (section B.5.6). Thus we have finally got the repository for our project, there is nothing left to do but find a suitable space on our harddisk and type:</p>
<pre><code>svn co URL_TO_YOUR_PROJECT MyProject</code></pre>
<p>The directory will be created on the harddisk. As usual the local copy of our project will be resident on the remote repository. Directories in RAM were temporary and therefore should be removed.</p>
</body>
</html>
